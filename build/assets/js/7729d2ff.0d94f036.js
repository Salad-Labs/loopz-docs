"use strict";(self.webpackChunksdk=self.webpackChunksdk||[]).push([[3824],{445:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var i=t(6687),s=t(4848),r=t(8453);const o={slug:"designing-react-first-web3-sdk",title:"Designing a React-First Web3 SDK: Patterns and Pitfalls",authors:["mattiamigliore"],tags:["react","sdk","architecture","hooks","web3"],date:new Date("2024-02-15T00:00:00.000Z"),description:"The architectural decisions, patterns, and lessons learned while building a React-first SDK for Web3 trading and chat."},a="Designing a React-First Web3 SDK: Patterns and Pitfalls",l={authorsImageUrls:[void 0]},c=[{value:"The Vision: Progressive Complexity",id:"the-vision-progressive-complexity",level:2},{value:"Architecture Decisions",id:"architecture-decisions",level:2},{value:"1. Provider Pattern with Context",id:"1-provider-pattern-with-context",level:3},{value:"2. The Hook Philosophy",id:"2-the-hook-philosophy",level:3},{value:"3. Error Boundaries That Make Sense",id:"3-error-boundaries-that-make-sense",level:3},{value:"4. State Management Strategy",id:"4-state-management-strategy",level:3},{value:"Patterns We Love",id:"patterns-we-love",level:2},{value:"1. The Initialization Guard Pattern",id:"1-the-initialization-guard-pattern",level:3},{value:"2. Event Emitter + React Bridge",id:"2-event-emitter--react-bridge",level:3},{value:"3. Progressive Enhancement",id:"3-progressive-enhancement",level:3},{value:"Pitfalls We Hit (So You Don&#39;t Have To)",id:"pitfalls-we-hit-so-you-dont-have-to",level:2},{value:"1. The SSR Nightmare",id:"1-the-ssr-nightmare",level:3},{value:"2. The Re-render Explosion",id:"2-the-re-render-explosion",level:3},{value:"3. The Memory Leak Trap",id:"3-the-memory-leak-trap",level:3},{value:"Testing Strategies",id:"testing-strategies",level:2},{value:"1. Mock Providers for Testing",id:"1-mock-providers-for-testing",level:3},{value:"2. Hook Testing",id:"2-hook-testing",level:3},{value:"Performance Optimizations",id:"performance-optimizations",level:2},{value:"1. Lazy Loading Features",id:"1-lazy-loading-features",level:3},{value:"2. Subscription Deduplication",id:"2-subscription-deduplication",level:3},{value:"Lessons for SDK Developers",id:"lessons-for-sdk-developers",level:2},{value:"The Future",id:"the-future",level:2},{value:"Final Thoughts",id:"final-thoughts",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Building an SDK is hard. Building a React-first SDK for Web3 is harder. You need to balance developer experience, performance, and the complexities of blockchain interactions. Here's how we approached it with the Loopz SDK."}),"\n",(0,s.jsx)(n.h2,{id:"the-vision-progressive-complexity",children:"The Vision: Progressive Complexity"}),"\n",(0,s.jsx)(n.p,{children:"We wanted developers to go from zero to trading platform in minutes, but also have the power to build complex features. This led to our layered architecture:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Level 1: Dead simple\n;<LoopzProvider config={config}>\n  <App />\n</LoopzProvider>\n\n// Level 2: Hook it up\nconst { authenticate } = useLoopzAuth()\n\n// Level 3: Go deep\nconst chat = Chat.getInstance()\nawait chat.customImplementation()\n"})}),"\n",(0,s.jsx)(n.h2,{id:"architecture-decisions",children:"Architecture Decisions"}),"\n",(0,s.jsx)(n.h3,{id:"1-provider-pattern-with-context",children:"1. Provider Pattern with Context"}),"\n",(0,s.jsx)(n.p,{children:"We went all-in on React Context, but with a twist - multiple nested providers for different concerns:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"export const LoopzProvider: FC<LoopzProviderProps> = ({ config, children }) => {\n  // Core SDK initialization\n  const [loopz, setLoopz] = useState<ILoopzContext>({\n    initialized: false,\n    instance: null,\n  })\n\n  useEffect(() => {\n    Loopz.boot(config).then((instance) => {\n      setLoopz({\n        initialized: true,\n        instance: instance.init(),\n      })\n    })\n  }, [])\n\n  if (!loopz.initialized) return null\n\n  return (\n    <LoopzContext.Provider value={loopz}>\n      <LoopzAuth {...config}>\n        <LoopzAuthProvider>\n          <LoopzChatProvider>{children}</LoopzChatProvider>\n        </LoopzAuthProvider>\n      </LoopzAuth>\n    </LoopzContext.Provider>\n  )\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Why nested providers?"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Separation of concerns"}),"\n",(0,s.jsx)(n.li,{children:"Conditional feature loading"}),"\n",(0,s.jsx)(n.li,{children:"Independent update cycles"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"2-the-hook-philosophy",children:"2. The Hook Philosophy"}),"\n",(0,s.jsx)(n.p,{children:"Every major feature gets a hook, but not everything needs to be a hook:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// \u2705 Good: Stateful operations\nexport const useLoopzAuth = () => {\n  const { instance } = useLoopz()\n  const [isLoading, setIsLoading] = useState(false)\n\n  const authenticate = useCallback(async () => {\n    setIsLoading(true)\n    try {\n      return await instance.auth.authenticate()\n    } finally {\n      setIsLoading(false)\n    }\n  }, [instance])\n\n  return { authenticate, isLoading }\n}\n\n// \u274c Bad: Simple getters don't need hooks\n// Don't do this:\nexport const useApiKey = () => {\n  const { instance } = useLoopz()\n  return instance.apiKey // No state, no effects, no need for a hook\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-error-boundaries-that-make-sense",children:"3. Error Boundaries That Make Sense"}),"\n",(0,s.jsx)(n.p,{children:"We created custom error classes for different scenarios:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'// Specific errors for specific problems\nexport class NotInitializedError extends Error {\n  constructor() {\n    super("SDK not initialized. Did you wrap your app with LoopzProvider?")\n    this.name = "NotInitializedError"\n  }\n}\n\nexport class ClientCantChatError extends Error {\n  constructor() {\n    super("Client cannot chat. E2E keys not generated.")\n    this.name = "ClientCantChatError"\n  }\n}\n\n// Usage in hooks\nconst connect = useCallback(() => {\n  if (!initialized) throw new NotInitializedError()\n  if (!canChat) throw new ClientCantChatError()\n  // ... rest of logic\n}, [initialized, canChat])\n'})}),"\n",(0,s.jsx)(n.h3,{id:"4-state-management-strategy",children:"4. State Management Strategy"}),"\n",(0,s.jsx)(n.p,{children:"We chose a hybrid approach:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Global state: In singleton classes\nclass Auth {\n  private static _instance: Auth\n  private static _isAuthenticated: boolean\n\n  static getInstance() {\n    return this._instance || new Auth()\n  }\n}\n\n// Component state: In React Context\nconst ChatContext = createContext<ChatState>({\n  isConnected: false,\n  messages: [],\n  conversations: [],\n})\n\n// Local state: In components\nfunction ChatMessage() {\n  const [isEditing, setIsEditing] = useState(false)\n  // Local UI state stays local\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"patterns-we-love",children:"Patterns We Love"}),"\n",(0,s.jsx)(n.h3,{id:"1-the-initialization-guard-pattern",children:"1. The Initialization Guard Pattern"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"export const useLoopzChat = () => {\n  const { initialized } = useLoopz()\n  const { isAuthenticated } = useLoopzAuth()\n\n  // Guard all methods\n  const connect = useCallback(() => {\n    if (!initialized) throw new NotInitializedError()\n    if (!isAuthenticated) throw new UnauthenticatedError()\n\n    // Safe to proceed\n    return instance.chat.connect()\n  }, [initialized, isAuthenticated])\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-event-emitter--react-bridge",children:"2. Event Emitter + React Bridge"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'// Core SDK uses event emitters\nclass Chat extends EventEmitter {\n  async sendMessage(content: string) {\n    const message = await this.api.send(content)\n    this.emit("messageReceived", message)\n    return message\n  }\n}\n\n// React hook bridges events to state\nexport const useLoopzChatEvent = (eventName: string, handler: Function) => {\n  const { instance } = useLoopz()\n\n  useEffect(() => {\n    if (!handler) return\n\n    instance.chat.on(eventName, handler)\n    return () => instance.chat.off(eventName, handler)\n  }, [eventName, handler])\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"3-progressive-enhancement",children:"3. Progressive Enhancement"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'// Basic usage\nfunction SimpleChat() {\n  const { sendMessage } = useLoopzChat()\n  return <button onClick={() => sendMessage("Hello!")}>Send</button>\n}\n\n// Advanced usage\nfunction AdvancedChat() {\n  const { instance } = useLoopz()\n\n  const sendEncryptedFile = async (file: File) => {\n    // Direct instance access for advanced features\n    const encrypted = await instance.chat.encryptFile(file)\n    return instance.chat.sendAttachment(encrypted)\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"pitfalls-we-hit-so-you-dont-have-to",children:"Pitfalls We Hit (So You Don't Have To)"}),"\n",(0,s.jsx)(n.h3,{id:"1-the-ssr-nightmare",children:"1. The SSR Nightmare"}),"\n",(0,s.jsx)(n.p,{children:"Next.js and Web3 don't play nice:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// \u274c This breaks SSR\nexport const LoopzProvider = () => {\n  const storage = new DexieStorage() // IndexedDB doesn't exist in Node!\n}\n\n// \u2705 Solution: Dynamic checks\nprivate static async createOrConnectToStorage() {\n  if (typeof window === 'undefined') {\n    return new MemoryStorage() // Fallback for SSR\n  }\n\n  return DexieStorage.createOrConnect({\n    dbName: CLIENT_DB_NAME,\n    dbVersion: 1\n  })\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-the-re-render-explosion",children:"2. The Re-render Explosion"}),"\n",(0,s.jsx)(n.p,{children:"Early versions triggered way too many re-renders:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// \u274c Bad: New object every render\nconst value = {\n  auth: instance.auth,\n  chat: instance.chat,\n  // ... etc\n}\n\n// \u2705 Good: Stable references\nconst value = useMemo(\n  () => ({\n    auth: instance.auth,\n    chat: instance.chat,\n  }),\n  [instance]\n)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-the-memory-leak-trap",children:"3. The Memory Leak Trap"}),"\n",(0,s.jsx)(n.p,{children:"WebSocket subscriptions are dangerous in React:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'// \u274c Leaky implementation\nuseEffect(() => {\n  instance.chat.on("message", handleMessage)\n  // Forgot to cleanup!\n})\n\n// \u2705 Proper cleanup\nuseEffect(() => {\n  const key = instance.notification.onMessage(handleMessage)\n\n  return () => {\n    instance.notification.offMessage(key) // Always cleanup!\n  }\n}, [])\n'})}),"\n",(0,s.jsx)(n.h2,{id:"testing-strategies",children:"Testing Strategies"}),"\n",(0,s.jsx)(n.h3,{id:"1-mock-providers-for-testing",children:"1. Mock Providers for Testing"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"export const MockLoopzProvider: FC = ({ children }) => {\n  const mockInstance = {\n    auth: {\n      authenticate: jest.fn().mockResolvedValue({ user: mockUser }),\n      logout: jest.fn(),\n    },\n    chat: {\n      connect: jest.fn().mockResolvedValue(true),\n      sendMessage: jest.fn(),\n    },\n  }\n\n  return (\n    <LoopzContext.Provider\n      value={{\n        initialized: true,\n        instance: mockInstance,\n      }}\n    >\n      {children}\n    </LoopzContext.Provider>\n  )\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-hook-testing",children:"2. Hook Testing"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'import { renderHook } from "@testing-library/react-hooks"\n\ntest("useLoopzAuth throws when not initialized", () => {\n  const { result } = renderHook(() => useLoopzAuth(), {\n    wrapper: ({ children }) => (\n      <LoopzContext.Provider value={{ initialized: false }}>\n        {children}\n      </LoopzContext.Provider>\n    ),\n  })\n\n  expect(() => result.current.authenticate()).toThrow(NotInitializedError)\n})\n'})}),"\n",(0,s.jsx)(n.h2,{id:"performance-optimizations",children:"Performance Optimizations"}),"\n",(0,s.jsx)(n.h3,{id:"1-lazy-loading-features",children:"1. Lazy Loading Features"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'// Only load chat when needed\nconst LoopzChatProvider = lazy(() => import("./LoopzChatProvider"))\n\nfunction App() {\n  const { needsChat } = useFeatureFlags()\n\n  return (\n    <LoopzProvider>\n      {needsChat ? (\n        <Suspense fallback={<ChatLoading />}>\n          <LoopzChatProvider>\n            <Chat />\n          </LoopzChatProvider>\n        </Suspense>\n      ) : (\n        <TradingOnly />\n      )}\n    </LoopzProvider>\n  )\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"2-subscription-deduplication",children:"2. Subscription Deduplication"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"class UUIDSubscriptionClient {\n  private subscriptions = new Map()\n\n  subscribe(query: string, variables: any) {\n    const key = `${query}-${JSON.stringify(variables)}`\n\n    // Return existing subscription\n    if (this.subscriptions.has(key)) {\n      return this.subscriptions.get(key)\n    }\n\n    // Create new subscription with UUID\n    const sub = this.client.request({\n      id: uuid(), // Prevents server duplicates\n      query,\n      variables,\n    })\n\n    this.subscriptions.set(key, sub)\n    return sub\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"lessons-for-sdk-developers",children:"Lessons for SDK Developers"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Start with the Developer Experience"}),": Write the code you want developers to write, then make it work."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Embrace TypeScript"}),": Our types are our documentation. Make them excellent."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Plan for Server-Side Rendering"}),": Even if you don't need it now, someone will."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Error Messages are UX"}),": ",(0,s.jsx)(n.code,{children:"throw new Error('bad')"})," helps no one. Be specific."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Test the Unhappy Path"}),": Network failures, auth errors, race conditions - test them all."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"the-future",children:"The Future"}),"\n",(0,s.jsx)(n.p,{children:"We're exploring:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Suspense Integration"}),": For better loading states"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Concurrent Features"}),": For smoother updates"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"React Server Components"}),": For hybrid rendering"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Custom DevTools"}),": For debugging complex states"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"final-thoughts",children:"Final Thoughts"}),"\n",(0,s.jsx)(n.p,{children:"Building a React SDK is about finding the right abstractions. Too low-level and developers struggle. Too high-level and they hit walls. The sweet spot is providing great defaults while keeping escape hatches open."}),"\n",(0,s.jsx)(n.p,{children:"Our mantra: Make simple things simple, and complex things possible."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.em,{children:["Building your own React SDK? We'd love to compare notes. Find us on ",(0,s.jsx)(n.a,{href:"https://github.com/Salad-Labs/loopz-typescript",children:"GitHub"})," or drop us a line at ",(0,s.jsx)(n.a,{href:"mailto:dev@saladlabs.xyz",children:"dev@saladlabs.xyz"})]})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},6687:e=>{e.exports=JSON.parse('{"permalink":"/loopz-docs/blog/designing-react-first-web3-sdk","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2024-03-25-designing-react-first-web3-sdk.md","source":"@site/blog/2024-03-25-designing-react-first-web3-sdk.md","title":"Designing a React-First Web3 SDK: Patterns and Pitfalls","description":"The architectural decisions, patterns, and lessons learned while building a React-first SDK for Web3 trading and chat.","date":"2024-02-15T00:00:00.000Z","tags":[{"inline":true,"label":"react","permalink":"/loopz-docs/blog/tags/react"},{"inline":true,"label":"sdk","permalink":"/loopz-docs/blog/tags/sdk"},{"inline":true,"label":"architecture","permalink":"/loopz-docs/blog/tags/architecture"},{"inline":true,"label":"hooks","permalink":"/loopz-docs/blog/tags/hooks"},{"inline":true,"label":"web3","permalink":"/loopz-docs/blog/tags/web-3"}],"readingTime":4.97,"hasTruncateMarker":true,"authors":[{"name":"Mattia Migliore","title":"Full Stack Developer, Web3 Dev, Co-founder & CTO Salad Labs","url":"https://www.linkedin.com/in/mattia-migliore-44886090/","page":{"permalink":"/loopz-docs/blog/authors/mattiamigliore"},"socials":{"x":"https://x.com/iamNFTia","linkedin":"https://www.linkedin.com/in/mattia-migliore-44886090/","github":"https://github.com/mattiNFT"},"imageURL":"https://media.licdn.com/dms/image/v2/D4D03AQGgX6OKMrEJig/profile-displayphoto-shrink_400_400/profile-displayphoto-shrink_400_400/0/1689936218116?e=1756339200&v=beta&t=J2TEZjssXl4PIkLrpfZNO48c74lzVb1hdeUCJW9FryA","key":"mattiamigliore"}],"frontMatter":{"slug":"designing-react-first-web3-sdk","title":"Designing a React-First Web3 SDK: Patterns and Pitfalls","authors":["mattiamigliore"],"tags":["react","sdk","architecture","hooks","web3"],"date":"2024-02-15T00:00:00.000Z","description":"The architectural decisions, patterns, and lessons learned while building a React-first SDK for Web3 trading and chat."},"unlisted":false,"prevItem":{"title":"Designing a Modular SDK Architecture for Web3 Applications","permalink":"/loopz-docs/blog/designing-modular-sdk-architecture-web3"},"nextItem":{"title":"Building a Real-Time Encrypted Chat System for Web3 Trading","permalink":"/loopz-docs/blog/building-encrypted-chat-web3"}}')},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var i=t(6540);const s={},r=i.createContext(s);function o(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);