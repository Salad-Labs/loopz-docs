"use strict";(self.webpackChunksdk=self.webpackChunksdk||[]).push([[5645],{7502:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>s,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"use-cases","title":"Use Cases","description":"Real-world use cases and implementation examples for the Loopz SDK","source":"@site/docs/use-cases.md","sourceDirName":".","slug":"/use-cases","permalink":"/loopz-docs/docs/use-cases","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/use-cases.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"id":"use-cases","title":"Use Cases","sidebar_label":"Use Cases","sidebar_position":4,"keywords":["use cases","examples","marketplace","trading","chat","NFT","real world"],"description":"Real-world use cases and implementation examples for the Loopz SDK"},"sidebar":"tutorialSidebar","previous":{"title":"Notifications","permalink":"/loopz-docs/docs/guides/notifications"},"next":{"title":"Troubleshooting","permalink":"/loopz-docs/docs/troubleshooting"}}');var r=t(4848),o=t(8453);const s={id:"use-cases",title:"Use Cases",sidebar_label:"Use Cases",sidebar_position:4,keywords:["use cases","examples","marketplace","trading","chat","NFT","real world"],description:"Real-world use cases and implementation examples for the Loopz SDK"},i="Use Cases",c={},l=[{value:"1. NFT Marketplace with Integrated Chat",id:"1-nft-marketplace-with-integrated-chat",level:2},{value:"Features",id:"features",level:3},{value:"Implementation",id:"implementation",level:3},{value:"2. P2P Trading Platform",id:"2-p2p-trading-platform",level:2},{value:"Features",id:"features-1",level:3},{value:"Implementation",id:"implementation-1",level:3},{value:"3. Gaming Item Exchange",id:"3-gaming-item-exchange",level:2},{value:"Features",id:"features-2",level:3},{value:"Implementation",id:"implementation-2",level:3},{value:"4. Social Trading Network",id:"4-social-trading-network",level:2},{value:"Features",id:"features-3",level:3},{value:"Implementation",id:"implementation-3",level:3},{value:"5. DeFi Trading Terminal",id:"5-defi-trading-terminal",level:2},{value:"Features",id:"features-4",level:3},{value:"Implementation",id:"implementation-4",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Error Handling",id:"1-error-handling",level:3},{value:"2. State Management",id:"2-state-management",level:3},{value:"3. Performance Optimization",id:"3-performance-optimization",level:3},{value:"4. Security Considerations",id:"4-security-considerations",level:3}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"use-cases",children:"Use Cases"})}),"\n",(0,r.jsx)(e.p,{children:"This section demonstrates real-world applications of the Loopz SDK with complete implementation examples. Each use case includes code samples, best practices, and considerations for production deployment."}),"\n",(0,r.jsx)(e.h2,{id:"1-nft-marketplace-with-integrated-chat",children:"1. NFT Marketplace with Integrated Chat"}),"\n",(0,r.jsx)(e.p,{children:"Build a complete NFT marketplace where users can browse, list, buy NFTs and negotiate trades through encrypted chat."}),"\n",(0,r.jsx)(e.h3,{id:"features",children:"Features"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Browse NFT collections"}),"\n",(0,r.jsx)(e.li,{children:"Create buy/sell orders"}),"\n",(0,r.jsx)(e.li,{children:"Direct messaging between buyers and sellers"}),"\n",(0,r.jsx)(e.li,{children:"Trade negotiation through chat"}),"\n",(0,r.jsx)(e.li,{children:"Secure escrow via smart contracts"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"implementation",children:"Implementation"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-tsx",children:'// NFTMarketplace.tsx\nimport React, { useState, useEffect } from "react"\nimport {\n  useLoopz,\n  useLoopzAuth,\n  useLoopzChat,\n} from "@salad-labs/loopz-typescript"\n\nfunction NFTMarketplace() {\n  const { instance } = useLoopz()\n  const { isAuthenticated, account } = useLoopzAuth()\n  const { connect, sync } = useLoopzChat()\n  const [listings, setListings] = useState([])\n  const [selectedNFT, setSelectedNFT] = useState(null)\n\n  // Load marketplace listings\n  useEffect(() => {\n    if (isAuthenticated) {\n      loadListings()\n    }\n  }, [isAuthenticated])\n\n  const loadListings = async () => {\n    try {\n      // Get orders from the marketplace using listOrders\n      const response = await instance.order.listOrders({\n        networkId: "1", // Ethereum mainnet\n        status: "active", // Status of orders\n        skip: 0,\n        take: 20,\n      })\n\n      if (response) {\n        setListings(response.orders)\n      }\n    } catch (error) {\n      console.error("Failed to load listings:", error)\n    }\n  }\n\n  // Create a listing for an NFT\n  const createListing = async (nft) => {\n    try {\n      const order = await instance.order.create(\n        wallet, // Connected wallet\n        {\n          address: account.wallet,\n          assets: [\n            {\n              token: nft.contractAddress,\n              tokenId: nft.tokenId,\n              amount: "1",\n              itemType: "ERC721",\n            },\n          ],\n        },\n        {\n          address: "", // Any buyer\n          assets: [\n            {\n              token: "0x0000000000000000000000000000000000000000", // ETH\n              amount: nft.price,\n              itemType: "NATIVE",\n            },\n          ],\n        },\n        7, // 7 days expiration\n        [], // No additional fees\n        null // No proposal ID\n      )\n\n      console.log("Listing created:", order)\n      loadListings() // Refresh listings\n    } catch (error) {\n      console.error("Failed to create listing:", error)\n    }\n  }\n\n  // Start chat with seller\n  const contactSeller = async (listing) => {\n    try {\n      // Connect to chat if not connected\n      if (!instance.chat.isConnected()) {\n        await connect()\n        await sync()\n      }\n\n      // Create or get existing conversation with seller\n      const conversation = await instance.chat.createConversation({\n        name: `Trade discussion: ${listing.nft.name}`,\n        description: `Discussing trade for ${listing.nft.name}`,\n        members: [listing.seller.did],\n        type: "PRIVATE",\n      })\n\n      // Send initial message\n      await instance.chat.createMessage({\n        conversationId: conversation.id,\n        content: `Hi! I\'m interested in your ${listing.nft.name} listing.`,\n        type: "TEXTUAL",\n      })\n\n      // Navigate to chat view\n      navigateToChat(conversation.id)\n    } catch (error) {\n      console.error("Failed to start chat:", error)\n    }\n  }\n\n  // Buy NFT directly\n  const buyNFT = async (listing) => {\n    try {\n      const result = await instance.order.finalize(listing.orderId)\n\n      if (result.success) {\n        alert("NFT purchased successfully!")\n        loadListings()\n      }\n    } catch (error) {\n      console.error("Failed to buy NFT:", error)\n    }\n  }\n\n  return (\n    <div className="nft-marketplace">\n      <h1>NFT Marketplace</h1>\n\n      <div className="listings-grid">\n        {listings.map((listing) => (\n          <div key={listing.id} className="nft-card">\n            <img src={listing.nft.imageUrl} alt={listing.nft.name} />\n            <h3>{listing.nft.name}</h3>\n            <p>Price: {listing.price} ETH</p>\n\n            <div className="actions">\n              <button onClick={() => buyNFT(listing)}>Buy Now</button>\n              <button onClick={() => contactSeller(listing)}>\n                Contact Seller\n              </button>\n            </div>\n          </div>\n        ))}\n      </div>\n    </div>\n  )\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"2-p2p-trading-platform",children:"2. P2P Trading Platform"}),"\n",(0,r.jsx)(e.p,{children:"Create a peer-to-peer trading platform where users can create complex trade proposals involving multiple NFTs and tokens."}),"\n",(0,r.jsx)(e.h3,{id:"features-1",children:"Features"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Multi-asset trade proposals"}),"\n",(0,r.jsx)(e.li,{children:"Counteroffers and negotiations"}),"\n",(0,r.jsx)(e.li,{children:"Trade history tracking"}),"\n",(0,r.jsx)(e.li,{children:"Reputation system"}),"\n",(0,r.jsx)(e.li,{children:"Escrow protection"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"implementation-1",children:"Implementation"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-tsx",children:'// P2PTradingPlatform.tsx\nimport React, { useState } from "react"\nimport {\n  useLoopz,\n  useLoopzAuth,\n  MessageMap,\n} from "@salad-labs/loopz-typescript"\n\nfunction P2PTradingPlatform() {\n  const { instance } = useLoopz()\n  const { account } = useLoopzAuth()\n  const [tradeProposal, setTradeProposal] = useState({\n    offered: [],\n    wanted: [],\n  })\n\n  // Create a trade proposal\n  const createTradeProposal = async () => {\n    try {\n      const proposal = await instance.proposal.create({\n        type: "TRADE",\n        networkId: "1",\n        creatorAddress: account.wallet,\n        expirationDate: Date.now() + 7 * 24 * 60 * 60 * 1000, // 7 days\n        assets: {\n          offered: tradeProposal.offered.map((asset) => ({\n            token: asset.contractAddress,\n            tokenId: asset.tokenId,\n            amount: asset.amount || "1",\n            type: asset.type, // ERC721, ERC1155, ERC20\n          })),\n          wanted: tradeProposal.wanted.map((asset) => ({\n            token: asset.contractAddress,\n            tokenId: asset.tokenId,\n            amount: asset.amount || "1",\n            type: asset.type,\n          })),\n        },\n        messages: [\n          {\n            type: MessageMap.MESSAGE_MATRIX["10"], // "This may be perfect for you"\n          },\n        ],\n      })\n\n      // Share proposal in chat\n      await shareProposalInChat(proposal)\n\n      console.log("Trade proposal created:", proposal)\n    } catch (error) {\n      console.error("Failed to create proposal:", error)\n    }\n  }\n\n  // Share proposal in trading chat room\n  const shareProposalInChat = async (proposal) => {\n    try {\n      // Get or create trading room\n      const tradingRoom =\n        (await instance.chat.getConversationByName("Global Trading Room")) ||\n        (await instance.chat.createConversation({\n          name: "Global Trading Room",\n          description: "Public trading discussion room",\n          type: "PUBLIC",\n        }))\n\n      // Send trade proposal message\n      await instance.chat.createMessage({\n        conversationId: tradingRoom.id,\n        type: "TRADE_PROPOSAL",\n        content: "Check out my new trade proposal!",\n        proposal: {\n          id: proposal.id,\n          offered: proposal.assets.offered,\n          wanted: proposal.assets.wanted,\n        },\n      })\n    } catch (error) {\n      console.error("Failed to share proposal:", error)\n    }\n  }\n\n  // Accept a trade proposal\n  const acceptProposal = async (proposalId) => {\n    try {\n      // Create order from proposal\n      const order = await instance.order.createFromProposal(\n        proposalId,\n        account.wallet\n      )\n\n      // Finalize the trade\n      const result = await instance.order.finalize(order.orderId)\n\n      if (result.success) {\n        console.log("Trade completed successfully!")\n      }\n    } catch (error) {\n      console.error("Failed to accept proposal:", error)\n    }\n  }\n\n  // Create a counteroffer\n  const createCounteroffer = async (originalProposalId) => {\n    try {\n      // Get original proposal\n      const original = await instance.proposal.getById(originalProposalId)\n\n      // Create new proposal with modified terms\n      const counteroffer = await instance.proposal.create({\n        ...original,\n        creatorAddress: account.wallet,\n        assets: {\n          offered: original.assets.wanted, // Swap offered/wanted\n          wanted: original.assets.offered,\n        },\n        parentProposalId: originalProposalId, // Link to original\n      })\n\n      // Send counteroffer notification\n      await notifyCounteroffer(original.creatorAddress, counteroffer)\n\n      return counteroffer\n    } catch (error) {\n      console.error("Failed to create counteroffer:", error)\n    }\n  }\n\n  return (\n    <div className="p2p-trading">\n      <h1>P2P Trading Platform</h1>\n\n      <TradeBuilder proposal={tradeProposal} onChange={setTradeProposal} />\n\n      <button onClick={createTradeProposal}>Create Trade Proposal</button>\n\n      <ActiveProposals onAccept={acceptProposal} />\n      <TradeHistory />\n    </div>\n  )\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"3-gaming-item-exchange",children:"3. Gaming Item Exchange"}),"\n",(0,r.jsx)(e.p,{children:"Build an exchange for in-game items where players can trade assets across different games."}),"\n",(0,r.jsx)(e.h3,{id:"features-2",children:"Features"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Cross-game item trading"}),"\n",(0,r.jsx)(e.li,{children:"Bulk trades for item sets"}),"\n",(0,r.jsx)(e.li,{children:"Price discovery through offers"}),"\n",(0,r.jsx)(e.li,{children:"Game-specific chat rooms"}),"\n",(0,r.jsx)(e.li,{children:"Collection tracking"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"implementation-2",children:"Implementation"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-tsx",children:'// GamingItemExchange.tsx\nimport React, { useState, useEffect } from "react"\nimport {\n  useLoopz,\n  useLoopzAuth,\n  useLoopzChat,\n} from "@salad-labs/loopz-typescript"\n\nfunction GamingItemExchange() {\n  const { instance } = useLoopz()\n  const { account } = useLoopzAuth()\n  const [gameRooms, setGameRooms] = useState({})\n  const [inventory, setInventory] = useState([])\n\n  // Initialize game-specific chat rooms\n  useEffect(() => {\n    initializeGameRooms()\n    loadPlayerInventory()\n  }, [])\n\n  const initializeGameRooms = async () => {\n    const games = ["Axie Infinity", "Gods Unchained", "The Sandbox"]\n\n    for (const game of games) {\n      try {\n        let room = await instance.chat.getConversationByName(`${game} Trading`)\n\n        if (!room) {\n          room = await instance.chat.createConversation({\n            name: `${game} Trading`,\n            description: `Trading room for ${game} items`,\n            type: "PUBLIC",\n            metadata: { game, type: "trading_room" },\n          })\n        }\n\n        setGameRooms((prev) => ({ ...prev, [game]: room }))\n      } catch (error) {\n        console.error(`Failed to setup ${game} room:`, error)\n      }\n    }\n  }\n\n  // Create bulk trade for item set\n  const createBulkTrade = async (items, targetGame) => {\n    try {\n      // Group items by collection\n      const groupedItems = items.reduce((acc, item) => {\n        if (!acc[item.collection]) acc[item.collection] = []\n        acc[item.collection].push(item)\n        return acc\n      }, {})\n\n      // Create proposal with all items\n      const proposal = await instance.proposal.create({\n        type: "TRADE",\n        networkId: "137", // Polygon\n        creatorAddress: account.wallet,\n        expirationDate: Date.now() + 3 * 24 * 60 * 60 * 1000, // 3 days\n        assets: {\n          offered: items.map((item) => ({\n            token: item.contractAddress,\n            tokenId: item.tokenId,\n            amount: item.amount || "1",\n            type: item.standard, // ERC721 or ERC1155\n          })),\n          wanted: [\n            {\n              token: "0x...", // Target game currency\n              amount: calculateBulkPrice(items),\n              type: "ERC20",\n            },\n          ],\n        },\n        messages: [\n          {\n            type: MessageMap.MESSAGE_MATRIX["001_002"], // "Anyone interested to these NFTs?"\n          },\n        ],\n        metadata: {\n          sourceGame: items[0].game,\n          targetGame,\n          itemCount: items.length,\n          rarity: calculateAverageRarity(items),\n        },\n      })\n\n      // Post in relevant game room\n      await postTradeInGameRoom(proposal, targetGame)\n\n      return proposal\n    } catch (error) {\n      console.error("Failed to create bulk trade:", error)\n    }\n  }\n\n  // Match complementary trades\n  const findMatchingTrades = async (myItems) => {\n    try {\n      // Get proposals using the list method\n      const proposalsResponse = await instance.proposal.list(\n        {\n          // Filter by network and type\n          networkId: "137",\n          type: Proposal.PROPOSAL_TYPE.TRADE,\n        },\n        undefined, // no ordering\n        0, // skip\n        100 // take\n      )\n\n      if (!proposalsResponse) return []\n\n      // Find proposals wanting what I have\n      const matches = proposalsResponse.proposals.filter((proposal) => {\n        const wantedTokens = proposal.assets.wanted.map((a) => a.token)\n        const myTokens = myItems.map((i) => i.contractAddress)\n\n        return wantedTokens.some((token) => myTokens.includes(token))\n      })\n\n      // Score matches by compatibility\n      const scoredMatches = matches.map((match) => ({\n        ...match,\n        score: calculateMatchScore(myItems, match),\n        mutualBenefit: checkMutualBenefit(myItems, match),\n      }))\n\n      return scoredMatches.sort((a, b) => b.score - a.score)\n    } catch (error) {\n      console.error("Failed to find matches:", error)\n      return []\n    }\n  }\n\n  // Create trade room for specific item set\n  const createItemSetRoom = async (setName, items) => {\n    try {\n      const room = await instance.chat.createConversation({\n        name: `Trading: ${setName}`,\n        description: `Exclusive room for ${setName} collectors`,\n        type: "PRIVATE",\n        metadata: {\n          itemSet: setName,\n          requiredItems: items.map((i) => i.tokenId),\n          createdBy: account.did,\n        },\n      })\n\n      // Invite collectors who own pieces\n      // Note: Finding collectors would require backend implementation\n      // or analyzing blockchain data\n      const collectors = [] // Would need to implement collector discovery\n\n      if (collectors.length > 0) {\n        // Add members to conversation\n        // Implementation depends on chat system design\n      }\n\n      return room\n    } catch (error) {\n      console.error("Failed to create item set room:", error)\n    }\n  }\n\n  return (\n    <div className="gaming-exchange">\n      <h1>Gaming Item Exchange</h1>\n\n      <div className="exchange-sections">\n        <InventoryManager\n          inventory={inventory}\n          onCreateTrade={createBulkTrade}\n        />\n\n        <TradeMatching onFindMatches={findMatchingTrades} />\n\n        <GameRoomsList rooms={gameRooms} />\n      </div>\n    </div>\n  )\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"4-social-trading-network",children:"4. Social Trading Network"}),"\n",(0,r.jsx)(e.p,{children:"Create a social platform where traders can follow each other, share strategies, and copy trades."}),"\n",(0,r.jsx)(e.h3,{id:"features-3",children:"Features"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Trader profiles with stats"}),"\n",(0,r.jsx)(e.li,{children:"Follow/unfollow traders"}),"\n",(0,r.jsx)(e.li,{children:"Copy trading functionality"}),"\n",(0,r.jsx)(e.li,{children:"Strategy sharing in chat"}),"\n",(0,r.jsx)(e.li,{children:"Performance leaderboards"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"implementation-3",children:"Implementation"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-tsx",children:'// SocialTradingNetwork.tsx\nimport React, { useState, useEffect } from "react"\nimport { useLoopz, useLoopzAuth } from "@salad-labs/loopz-typescript"\n\nfunction SocialTradingNetwork() {\n  const { instance } = useLoopz()\n  const { account } = useLoopzAuth()\n  const [following, setFollowing] = useState([])\n  const [topTraders, setTopTraders] = useState([])\n  const [strategyRooms, setStrategyRooms] = useState([])\n\n  // Get top traders by performance\n  const loadTopTraders = async () => {\n    try {\n      // Note: This is a hypothetical implementation\n      // The Oracle class doesn\'t have a getTopTraders method\n      // You would need to implement this logic using available methods\n      // or fetch from your own backend\n\n      console.log("Load top traders - implement with your backend")\n\n      // Example: Get NFT collections and analyze trading volume\n      const collections = await instance.oracle.listCollections({\n        networkId: "1",\n        searchType: "volume",\n        skip: 0,\n        take: 50,\n      })\n\n      // Process collections data to identify top traders\n      // This would require additional backend logic\n    } catch (error) {\n      console.error("Failed to load top traders:", error)\n    }\n  }\n\n  // Follow a trader and join their strategy room\n  const followTrader = async (traderId) => {\n    try {\n      // Note: The notification class doesn\'t have a subscribe method\n      // You would need to implement follower logic in your backend\n\n      // Join trader\'s strategy discussion room\n      const conversations = await instance.chat.getConversations()\n      const traderRoom = conversations.find(\n        (conv) => conv.name === `${traderId}\'s Strategy Room`\n      )\n\n      if (traderRoom && traderRoom.type === "PUBLIC") {\n        // Join existing conversation\n        // Note: joinConversation might need to be implemented\n        // depending on how chat membership works\n        setStrategyRooms((prev) => [...prev, traderRoom])\n      }\n\n      // Update following list locally\n      setFollowing((prev) => [...prev, traderId])\n\n      // Analyze trader\'s recent trades\n      const traderOrders = await instance.order.listUserOrders({\n        networkId: "1",\n        did: traderId,\n        status: "*", // All statuses\n        skip: 0,\n        take: 20,\n      })\n\n      console.log("Trader orders:", traderOrders)\n    } catch (error) {\n      console.error("Failed to follow trader:", error)\n    }\n  }\n\n  // Copy a trader\'s trade\n  const copyTrade = async (originalTrade) => {\n    try {\n      // Adjust position size based on portfolio\n      const adjustedSize = calculatePositionSize(\n        originalTrade,\n        account.portfolioValue\n      )\n\n      // Create similar order\n      const copiedOrder = await instance.order.create(\n        wallet,\n        {\n          address: account.wallet,\n          assets: originalTrade.offered.map((asset) => ({\n            ...asset,\n            amount: adjustedSize,\n          })),\n        },\n        {\n          address: originalTrade.counterparty,\n          assets: originalTrade.wanted,\n        },\n        originalTrade.expiration,\n        originalTrade.fees,\n        null\n      )\n\n      // Track as copied trade\n      // Note: This would need to be implemented in your backend\n      // The SDK doesn\'t have built-in analytics tracking\n      console.log("Trade copied:", {\n        originalTradeId: originalTrade.id,\n        copiedOrderId: copiedOrder.orderId,\n        originalTrader: originalTrade.creator,\n        scaleFactor: adjustedSize / originalTrade.offered[0].amount,\n      })\n\n      return copiedOrder\n    } catch (error) {\n      console.error("Failed to copy trade:", error)\n    }\n  }\n\n  // Share trading strategy\n  const shareStrategy = async (strategy) => {\n    try {\n      // Create strategy document\n      const strategyDoc = {\n        title: strategy.title,\n        description: strategy.description,\n        rules: strategy.rules,\n        backtestResults: strategy.backtest,\n        riskMetrics: strategy.risk,\n        author: account.did,\n      }\n\n      // Create dedicated strategy room\n      const room = await instance.chat.createConversation({\n        name: `Strategy: ${strategy.title}`,\n        description: strategy.description,\n        type: "PUBLIC",\n        metadata: {\n          type: "strategy_discussion",\n          strategy: strategyDoc,\n        },\n      })\n\n      // Share in main strategy feed\n      await instance.chat.createMessage({\n        conversationId: "strategy-feed",\n        type: "TEXTUAL",\n        content: `New strategy shared: ${strategy.title}`,\n        attachments: [\n          {\n            type: "strategy",\n            data: strategyDoc,\n          },\n        ],\n      })\n\n      // Create automated alerts for strategy signals\n      // Note: This would need backend implementation\n      // The SDK doesn\'t have built-in alert mechanisms\n      console.log("Strategy shared:", room.id)\n\n      return room\n    } catch (error) {\n      console.error("Failed to share strategy:", error)\n    }\n  }\n\n  // Performance tracking dashboard\n  const TraderDashboard = ({ trader }) => {\n    const [stats, setStats] = useState(null)\n\n    useEffect(() => {\n      // Note: This is a simplified version\n      // Real implementation would need proper stats tracking\n      const loadTraderStats = async (traderId) => {\n        try {\n          const orders = await instance.order.listUserOrders({\n            networkId: "1",\n            did: traderId,\n            status: "*",\n            skip: 0,\n            take: 100,\n          })\n\n          // Calculate stats from orders\n          const stats = {\n            winRate: 0, // Calculate from order history\n            avgROI: 0, // Calculate from order values\n            totalTrades: orders?.total || 0,\n            followers: 0, // Would need backend tracking\n          }\n\n          return stats\n        } catch (error) {\n          console.error("Failed to load trader stats:", error)\n          return null\n        }\n      }\n\n      loadTraderStats(trader.id).then(setStats)\n    }, [trader.id])\n\n    return (\n      <div className="trader-dashboard">\n        <h3>{trader.username}</h3>\n        <div className="stats-grid">\n          <Stat label="Win Rate" value={`${stats?.winRate}%`} />\n          <Stat label="Avg ROI" value={`${stats?.avgROI}%`} />\n          <Stat label="Total Trades" value={stats?.totalTrades} />\n          <Stat label="Followers" value={stats?.followers} />\n        </div>\n\n        <div className="actions">\n          <button onClick={() => followTrader(trader.id)}>Follow</button>\n          <button onClick={() => viewTraderHistory(trader.id)}>\n            View History\n          </button>\n        </div>\n      </div>\n    )\n  }\n\n  return (\n    <div className="social-trading">\n      <h1>Social Trading Network</h1>\n\n      <LeaderboardSection traders={topTraders} />\n\n      <FollowingSection following={following} onCopyTrade={copyTrade} />\n\n      <StrategyFeed rooms={strategyRooms} onShareStrategy={shareStrategy} />\n\n      <PerformanceAnalytics />\n    </div>\n  )\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"5-defi-trading-terminal",children:"5. DeFi Trading Terminal"}),"\n",(0,r.jsx)(e.p,{children:"Build a professional trading terminal for DeFi assets with advanced order types and real-time data."}),"\n",(0,r.jsx)(e.h3,{id:"features-4",children:"Features"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Real-time price feeds"}),"\n",(0,r.jsx)(e.li,{children:"Advanced order types (limit, stop-loss)"}),"\n",(0,r.jsx)(e.li,{children:"Portfolio tracking"}),"\n",(0,r.jsx)(e.li,{children:"Trading signals via chat"}),"\n",(0,r.jsx)(e.li,{children:"Multi-chain support"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"implementation-4",children:"Implementation"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-tsx",children:'// DeFiTradingTerminal.tsx\nimport React, { useState, useEffect } from "react"\nimport {\n  useLoopz,\n  useLoopzAuth,\n  useLoopzChat,\n} from "@salad-labs/loopz-typescript"\n\nfunction DeFiTradingTerminal() {\n  const { instance } = useLoopz()\n  const { account } = useLoopzAuth()\n  const [orderBook, setOrderBook] = useState({ bids: [], asks: [] })\n  const [positions, setPositions] = useState([])\n  const [signalsRoom, setSignalsRoom] = useState(null)\n\n  // Initialize trading signals room\n  useEffect(() => {\n    initializeSignalsRoom()\n    subscribeToMarketData()\n  }, [])\n\n  const initializeSignalsRoom = async () => {\n    try {\n      // Connect to chat\n      await instance.chat.connect()\n      await instance.chat.sync()\n\n      // Create or get signals room\n      const conversations = await instance.chat.getConversations()\n      let room = conversations.find(\n        (conv) => conv.name === "DeFi Trading Signals"\n      )\n\n      if (!room) {\n        room = await instance.chat.createConversation({\n          name: "DeFi Trading Signals",\n          description: "Automated trading signals and alerts",\n          type: "PUBLIC",\n          metadata: {\n            type: "signals",\n            automated: true,\n          },\n        })\n      }\n\n      setSignalsRoom(room)\n\n      // Listen for new messages in the signals room\n      instance.chat.on("messageReceived", (message) => {\n        if (message.conversationId === room.id) {\n          handleTradingSignal(message)\n        }\n      })\n    } catch (error) {\n      console.error("Failed to setup signals room:", error)\n    }\n  }\n\n  // Create limit order\n  const createLimitOrder = async (params) => {\n    try {\n      const order = await instance.order.create(\n        wallet,\n        {\n          address: account.wallet,\n          assets: [\n            {\n              token: params.sellToken,\n              amount: params.sellAmount,\n              itemType: "ERC20",\n            },\n          ],\n        },\n        {\n          address: "", // Any taker\n          assets: [\n            {\n              token: params.buyToken,\n              amount: params.buyAmount,\n              itemType: "ERC20",\n            },\n          ],\n        },\n        params.expiration || 1, // 1 day default\n        [\n          {\n            recipient: account.wallet,\n            basisPoints: 0, // No fees for limit orders\n          },\n        ]\n      )\n\n      // Broadcast order to signals room\n      await broadcastOrder(order, "LIMIT")\n\n      return order\n    } catch (error) {\n      console.error("Failed to create limit order:", error)\n    }\n  }\n\n  // Create stop-loss order\n  const createStopLossOrder = async (position, stopPrice) => {\n    try {\n      // Note: Oracle doesn\'t have monitorPrice method\n      // Stop-loss logic would need to be implemented in your backend\n      // or using a combination of periodic checks\n\n      console.log("Stop-loss order created:", {\n        position,\n        stopPrice,\n      })\n\n      // You could implement this by:\n      // 1. Setting up a backend job to monitor prices\n      // 2. Using a third-party service for price alerts\n      // 3. Implementing client-side polling (not recommended)\n\n      // When stop price is hit, create and execute order:\n      /*\n      const order = await instance.order.create(\n        wallet,\n        {\n          address: account.wallet,\n          assets: [{\n            token: position.token,\n            amount: position.amount,\n            itemType: \'ERC20\'\n          }]\n        },\n        {\n          address: \'\',\n          assets: [{\n            token: \'0x...\', // USDC\n            amount: calculateMarketValue(position),\n            itemType: \'ERC20\'\n          }]\n        },\n        0, // Immediate\n        []\n      )\n      \n      await instance.order.finalize(order.orderId)\n      */\n\n      return { id: Date.now(), position, stopPrice }\n    } catch (error) {\n      console.error("Failed to create stop-loss:", error)\n    }\n  }\n\n  // Broadcast trading signals\n  const broadcastOrder = async (order, type) => {\n    if (!signalsRoom) return\n\n    try {\n      await instance.chat.createMessage({\n        conversationId: signalsRoom.id,\n        type: "TRADE_PROPOSAL",\n        content: `New ${type} order created`,\n        metadata: {\n          orderType: type,\n          orderId: order.orderId,\n          pair: `${order.offer[0].token}/${order.consideration[0].token}`,\n          price: calculatePrice(order),\n          size: order.offer[0].amount,\n          creator: account.did,\n        },\n      })\n    } catch (error) {\n      console.error("Failed to broadcast order:", error)\n    }\n  }\n\n  // Portfolio tracker\n  const PortfolioTracker = () => {\n    const [portfolio, setPortfolio] = useState({\n      totalValue: 0,\n      positions: [],\n      pnl: 0,\n    })\n\n    useEffect(() => {\n      updatePortfolio()\n      const interval = setInterval(updatePortfolio, 30000) // Update every 30s\n      return () => clearInterval(interval)\n    }, [])\n\n    const updatePortfolio = async () => {\n      try {\n        // Get user\'s NFT collections\n        const collectibles = await instance.oracle.listCollectibles({\n          owner: account.wallet,\n          networkId: "1",\n        })\n\n        // For tokens, you would need to use web3 libraries directly\n        // or implement your own token balance fetching\n\n        // Calculate portfolio value\n        // Note: getTokenValue doesn\'t exist in Oracle\n        // You would need to implement price fetching from external sources\n\n        const portfolioData = {\n          totalValue: 0, // Calculate based on current prices\n          positions: collectibles || [],\n          pnl: 0, // Calculate based on historical data\n        }\n\n        setPortfolio(portfolioData)\n\n        // Send performance update to signals room if significant P&L\n        if (Math.abs(portfolioData.pnl) > 100) {\n          await instance.chat.createMessage({\n            conversationId: signalsRoom.id,\n            type: "TEXTUAL",\n            content: `Portfolio Update: ${\n              portfolioData.pnl >= 0 ? "+" : ""\n            }${portfolioData.pnl.toFixed(2)}% P&L`,\n          })\n        }\n      } catch (error) {\n        console.error("Failed to update portfolio:", error)\n      }\n    }\n\n    return (\n      <div className="portfolio-tracker">\n        <h3>Portfolio Value: ${portfolio.totalValue.toFixed(2)}</h3>\n        <p className={portfolio.pnl >= 0 ? "profit" : "loss"}>\n          P&L: {portfolio.pnl >= 0 ? "+" : ""}\n          {portfolio.pnl.toFixed(2)}%\n        </p>\n\n        <PositionsList positions={portfolio.positions} />\n      </div>\n    )\n  }\n\n  return (\n    <div className="defi-terminal">\n      <h1>DeFi Trading Terminal</h1>\n\n      <div className="terminal-layout">\n        <ChartSection />\n\n        <OrderBook book={orderBook} onPlaceOrder={createLimitOrder} />\n\n        <TradingPanel\n          onLimitOrder={createLimitOrder}\n          onStopLoss={createStopLossOrder}\n        />\n\n        <PortfolioTracker />\n\n        <SignalsChat room={signalsRoom} />\n      </div>\n    </div>\n  )\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(e.h3,{id:"1-error-handling",children:"1. Error Handling"}),"\n",(0,r.jsx)(e.p,{children:"Always implement comprehensive error handling:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:"try {\n  await instance.order.create(...)\n} catch (error) {\n  if (error.code === 'INSUFFICIENT_BALANCE') {\n    // Handle specific error\n  } else {\n    // Generic error handling\n  }\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"2-state-management",children:"2. State Management"}),"\n",(0,r.jsx)(e.p,{children:"Use proper state management for complex applications:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:"// Using Redux or Zustand for global state\nconst useTradeStore = create((set) => ({\n  trades: [],\n  addTrade: (trade) =>\n    set((state) => ({\n      trades: [...state.trades, trade],\n    })),\n  removeTrade: (id) =>\n    set((state) => ({\n      trades: state.trades.filter((t) => t.id !== id),\n    })),\n}))\n"})}),"\n",(0,r.jsx)(e.h3,{id:"3-performance-optimization",children:"3. Performance Optimization"}),"\n",(0,r.jsx)(e.p,{children:"Implement pagination and caching:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:"const loadTrades = async (page = 1, limit = 20) => {\n  const cached = cache.get(`trades_${page}`)\n  if (cached) return cached\n\n  const trades = await instance.order.getOrders({\n    page,\n    limit,\n  })\n\n  cache.set(`trades_${page}`, trades, 300) // 5 min cache\n  return trades\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"4-security-considerations",children:"4. Security Considerations"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Always validate user inputs"}),"\n",(0,r.jsx)(e.li,{children:"Implement rate limiting"}),"\n",(0,r.jsx)(e.li,{children:"Use environment variables for sensitive data"}),"\n",(0,r.jsx)(e.li,{children:"Verify transaction parameters before execution"}),"\n"]})]})}function p(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>s,x:()=>i});var a=t(6540);const r={},o=a.createContext(r);function s(n){const e=a.useContext(o);return a.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function i(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:s(n.components),a.createElement(o.Provider,{value:e},n.children)}}}]);