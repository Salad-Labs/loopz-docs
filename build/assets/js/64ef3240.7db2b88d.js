"use strict";(self.webpackChunksdk=self.webpackChunksdk||[]).push([[4903],{152:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});var i=t(7503),r=t(4848),o=t(8453);const a={slug:"designing-modular-sdk-architecture-web3",title:"Designing a Modular SDK Architecture for Web3 Applications",authors:["mattiamigliore"],tags:["architecture","sdk","typescript","design-patterns","web3"],date:new Date("2024-02-20T00:00:00.000Z")},s="Designing a Modular SDK Architecture for Web3 Applications",l={authorsImageUrls:[void 0]},c=[{value:"The Challenge",id:"the-challenge",level:2},{value:"The Architecture",id:"the-architecture",level:2},{value:"1. The Singleton Pattern with a Twist",id:"1-the-singleton-pattern-with-a-twist",level:3},{value:"2. Module Independence",id:"2-module-independence",level:3},{value:"3. The Provider Pattern for React",id:"3-the-provider-pattern-for-react",level:3},{value:"4. Hook Architecture",id:"4-hook-architecture",level:3},{value:"Type Safety First",id:"type-safety-first",level:2},{value:"1. Comprehensive Type Definitions",id:"1-comprehensive-type-definitions",level:3},{value:"2. Discriminated Unions for Errors",id:"2-discriminated-unions-for-errors",level:3},{value:"3. Branded Types for Safety",id:"3-branded-types-for-safety",level:3},{value:"State Management Philosophy",id:"state-management-philosophy",level:2},{value:"1. Local-First with IndexedDB",id:"1-local-first-with-indexeddb",level:3},{value:"2. Event-Driven Architecture",id:"2-event-driven-architecture",level:3},{value:"Handling Complexity",id:"handling-complexity",level:2},{value:"1. The Adapter Pattern",id:"1-the-adapter-pattern",level:3},{value:"2. Graceful Degradation",id:"2-graceful-degradation",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"1. Lazy Loading",id:"1-lazy-loading",level:3},{value:"2. Tree Shaking Support",id:"2-tree-shaking-support",level:3},{value:"Lessons Learned",id:"lessons-learned",level:2},{value:"What This Enables",id:"what-this-enables",level:2},{value:"Future Improvements",id:"future-improvements",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Building an SDK is like designing a city - you need to think about how different parts connect, how people (developers) will navigate it, and how it can grow without becoming a maze. When we started building the Loopz SDK, we knew we needed an architecture that could handle authentication, real-time chat, trading, and blockchain interactions - all while remaining intuitive for developers."}),"\n",(0,r.jsx)(n.h2,{id:"the-challenge",children:"The Challenge"}),"\n",(0,r.jsx)(n.p,{children:"Our SDK needed to:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Support multiple independent features (auth, chat, trading, etc.)"}),"\n",(0,r.jsx)(n.li,{children:"Work in both React and vanilla JavaScript environments"}),"\n",(0,r.jsx)(n.li,{children:"Handle complex state management"}),"\n",(0,r.jsx)(n.li,{children:"Provide great TypeScript support"}),"\n",(0,r.jsx)(n.li,{children:"Scale without becoming a monolith"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"the-architecture",children:"The Architecture"}),"\n",(0,r.jsx)(n.h3,{id:"1-the-singleton-pattern-with-a-twist",children:"1. The Singleton Pattern with a Twist"}),"\n",(0,r.jsx)(n.p,{children:"Instead of traditional singletons, we created a managed singleton system:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"export class Loopz {\n  private static _instance: Loopz\n  private static _config: LoopzConfig\n\n  // Boot method instead of direct instantiation\n  static async boot(\n    config: LoopzConfig,\n    options?: {\n      devMode?: boolean\n      runAdapter?: boolean\n      enableStorage?: boolean\n    }\n  ): Promise<Loopz> {\n    if (!Loopz._instance) {\n      // Create storage connection\n      const storage = await Loopz.createOrConnectToStorage()\n\n      // Initialize instance\n      Loopz._instance = new Loopz(\n        {\n          ...config,\n          storage,\n        },\n        options\n      )\n    }\n\n    return Loopz._instance\n  }\n\n  // Initialize all modules\n  init() {\n    return {\n      auth: Auth.getInstance(),\n      chat: Chat.getInstance(),\n      order: Order.getInstance(),\n      proposal: Proposal.getInstance(),\n      oracle: Oracle.getInstance(),\n      notification: Notification.getInstance(),\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"This pattern provides:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Lazy initialization"}),"\n",(0,r.jsx)(n.li,{children:"Configuration validation"}),"\n",(0,r.jsx)(n.li,{children:"Centralized module management"}),"\n",(0,r.jsx)(n.li,{children:"Clean dependency injection"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"2-module-independence",children:"2. Module Independence"}),"\n",(0,r.jsx)(n.p,{children:"Each module follows a consistent pattern:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'export class Chat {\n  private static _config: ChatConfig\n  private static _instance: Chat\n\n  // Configuration must happen before instantiation\n  static config(config: ChatConfig) {\n    if (Chat._config) throw new Error("Chat already configured")\n    Chat._config = config\n  }\n\n  static getInstance() {\n    return Chat._instance ?? new Chat()\n  }\n\n  private constructor() {\n    if (!Chat._config) {\n      throw new Error("Chat must be configured before getting instance")\n    }\n    // Initialize with config\n  }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"This ensures:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Modules can't be used without configuration"}),"\n",(0,r.jsx)(n.li,{children:"Each module manages its own lifecycle"}),"\n",(0,r.jsx)(n.li,{children:"Clear initialization order"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"3-the-provider-pattern-for-react",children:"3. The Provider Pattern for React"}),"\n",(0,r.jsx)(n.p,{children:"We created a comprehensive provider system for React applications:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Root provider that manages everything\nexport const LoopzProvider: FC<LoopzProviderProps> = ({\n  config,\n  chatConfig,\n  devMode = false,\n  children,\n}) => {\n  const [loopz, setLoopz] = useState<ILoopzContext>({\n    initialized: false,\n    instance: null,\n  })\n\n  useEffect(() => {\n    Loopz.boot(config, { devMode }).then((loopz) => {\n      setLoopz({\n        initialized: true,\n        instance: loopz.init(),\n      })\n    })\n  }, [])\n\n  if (!loopz.initialized) return null\n\n  return (\n    <LoopzContext.Provider value={loopz}>\n      <LoopzAuth {...config}>\n        <LoopzAuthProvider>\n          {chatConfig ? (\n            <LoopzChatProvider {...chatConfig}>{children}</LoopzChatProvider>\n          ) : (\n            children\n          )}\n        </LoopzAuthProvider>\n      </LoopzAuth>\n    </LoopzContext.Provider>\n  )\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"4-hook-architecture",children:"4. Hook Architecture"}),"\n",(0,r.jsx)(n.p,{children:"Our hooks follow a consistent pattern with built-in error handling:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'export const useLoopzAuth = () => {\n  const loopzContext = useContext(LoopzContext)\n  const authContext = useContext(LoopzAuthContext)\n\n  if (!loopzContext || !authContext) {\n    throw new Error("useLoopzAuth() must be used within <LoopzProvider>")\n  }\n\n  const { initialized, instance } = loopzContext\n  const { isAuthenticated, isLoading, account } = authContext\n\n  const authenticate = useCallback(() => {\n    if (!initialized) throw new NotInitializedError()\n    if (isLoading) throw new LoadingError("authenticate()", "Auth")\n\n    return !isAuthenticated\n      ? instance.auth.authenticate()\n      : Promise.resolve({ auth, account })\n  }, [initialized, isLoading, isAuthenticated])\n\n  return {\n    ...authContext,\n    authenticate,\n    // other methods\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"type-safety-first",children:"Type Safety First"}),"\n",(0,r.jsx)(n.h3,{id:"1-comprehensive-type-definitions",children:"1. Comprehensive Type Definitions"}),"\n",(0,r.jsx)(n.p,{children:"Every module has detailed TypeScript definitions:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"export type UseLoopzChat = (config?: {\n  onMessageReceived?: (message: Message) => void\n  onMessageUpdated?: (message: Message) => void\n  onMessageDeleted?: (messageId: string) => void\n  // ... 20+ more event handlers\n}) => LoopzChatContextValue & {\n  connect(): Promise<void>\n  disconnect(): Promise<void>\n  sync(): Promise<void>\n  // ... more methods\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-discriminated-unions-for-errors",children:"2. Discriminated Unions for Errors"}),"\n",(0,r.jsx)(n.p,{children:"We use discriminated unions for better error handling:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"export class QIError extends CombinedError {\n  reason: Maybe<string> = null\n  standardError: boolean = true\n\n  constructor(\n    input: {\n      networkError?: Error\n      graphQLErrors?: ErrorLike[]\n      response?: any\n    },\n    reason: string,\n    standardError: boolean\n  ) {\n    super(input)\n    this.reason = reason\n    this.standardError = standardError\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"3-branded-types-for-safety",children:"3. Branded Types for Safety"}),"\n",(0,r.jsx)(n.p,{children:"We use branded types to prevent mixing up IDs:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'type ConversationId = string & { __brand: "ConversationId" }\ntype MessageId = string & { __brand: "MessageId" }\ntype UserId = string & { __brand: "UserId" }\n\n// Prevents accidents like:\n// sendMessage(userId, message) // TypeScript error!\n// sendMessage(conversationId, message) // Correct\n'})}),"\n",(0,r.jsx)(n.h2,{id:"state-management-philosophy",children:"State Management Philosophy"}),"\n",(0,r.jsx)(n.h3,{id:"1-local-first-with-indexeddb",children:"1. Local-First with IndexedDB"}),"\n",(0,r.jsx)(n.p,{children:"We built a complete storage layer on top of Dexie:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'export class DexieStorage {\n  private _db: Dexie\n  private _storageEnabled: boolean = true\n\n  constructor(config: DexieConfig) {\n    this._db = new Dexie(config.dbName)\n\n    // Define schema\n    this._db.version(config.dbVersion).stores({\n      user: "++[did+organizationId], wallet",\n      conversation: "++[id+userDid], name, type, order",\n      message: "++[id+userDid], conversationId, order",\n      member: "++[id+userId], conversationId",\n      // ... more tables\n    })\n  }\n\n  // Typed table access\n  get user() {\n    return this._db.table<LocalDBUser>("user")\n  }\n  get conversation() {\n    return this._db.table<LocalDBConversation>("conversation")\n  }\n  // ... more getters\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"2-event-driven-architecture",children:"2. Event-Driven Architecture"}),"\n",(0,r.jsx)(n.p,{children:"Every module emits events for state changes:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Internal event system\nclass EventEmitter {\n  private _events: Map<string, Set<Function>> = new Map()\n\n  on(event: string, callback: Function, once = false) {\n    if (!this._events.has(event)) {\n      this._events.set(event, new Set())\n    }\n\n    const wrapper = once\n      ? (...args: any[]) => {\n          callback(...args)\n          this.off(event, wrapper)\n        }\n      : callback\n\n    this._events.get(event)!.add(wrapper)\n\n    return () => this.off(event, wrapper)\n  }\n\n  emit(event: string, ...args: any[]) {\n    this._events.get(event)?.forEach((callback) => {\n      callback(...args)\n    })\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"handling-complexity",children:"Handling Complexity"}),"\n",(0,r.jsx)(n.h3,{id:"1-the-adapter-pattern",children:"1. The Adapter Pattern"}),"\n",(0,r.jsx)(n.p,{children:"For third-party integrations, we use adapters:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'export class PrivyAdapter {\n  private _container: HTMLElement\n  private _root: Root\n\n  constructor(options: PrivyAdapterOptions) {\n    // Create isolated React root for Privy\n    this._container = document.createElement("div")\n    document.body.appendChild(this._container)\n    this._root = createRoot(this._container)\n  }\n\n  render() {\n    this._root.render(\n      <PrivyContext appId={this._privyAppId} config={this._privyConfig} />\n    )\n  }\n\n  cleanup() {\n    this._root.unmount()\n    document.body.removeChild(this._container)\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"2-graceful-degradation",children:"2. Graceful Degradation"}),"\n",(0,r.jsx)(n.p,{children:"The SDK works even when some features aren't available:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// Storage can be disabled for testing\nif (options.enableStorage === false) {\n  storage.disableStorage()\n}\n\n// Chat works without notifications\nif (!instance.notification.isInitialized()) {\n  console.warn("Notifications unavailable, chat will work without them")\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,r.jsx)(n.h3,{id:"1-lazy-loading",children:"1. Lazy Loading"}),"\n",(0,r.jsx)(n.p,{children:"Modules are only initialized when needed:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Heavy modules like Order only initialize when used\nasync initializeOrder(wallet: ConnectedWallet) {\n  if (!this._initialized) {\n    await this.init(wallet) // Connect to blockchain\n    this._initialized = true\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-tree-shaking-support",children:"2. Tree Shaking Support"}),"\n",(0,r.jsx)(n.p,{children:"The modular architecture enables effective tree shaking:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// Users can import only what they need\nimport { useLoopzAuth } from "@salad-labs/loopz-typescript/auth"\n// Instead of importing everything\nimport { useLoopzAuth } from "@salad-labs/loopz-typescript"\n'})}),"\n",(0,r.jsx)(n.h2,{id:"lessons-learned",children:"Lessons Learned"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Configuration Before Instantiation"}),": Forcing configuration before module creation prevents runtime errors"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Consistent Patterns"}),": Using the same patterns across modules reduces cognitive load"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Type Safety Pays Off"}),": Investing in comprehensive types catches bugs early"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Events Over Callbacks"}),": Event-driven architecture is more flexible than callback props"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Provider Composition"}),": Nested providers allow feature-specific configuration"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"what-this-enables",children:"What This Enables"}),"\n",(0,r.jsx)(n.p,{children:"Our architecture allows developers to:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Use only what they need\n<LoopzProvider config={config}>\n  <MyApp /> {/* Just auth */}\n</LoopzProvider>\n\n// Or everything\n<LoopzProvider config={config} chatConfig={chatConfig}>\n  <TradingApp /> {/* Full features */}\n</LoopzProvider>\n\n// Or vanilla JS\nconst loopz = await Loopz.boot(config)\nconst { auth } = loopz.init()\nawait auth.authenticate()\n"})}),"\n",(0,r.jsx)(n.h2,{id:"future-improvements",children:"Future Improvements"}),"\n",(0,r.jsx)(n.p,{children:"We're constantly evolving the architecture:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Plugin system for third-party extensions"}),"\n",(0,r.jsx)(n.li,{children:"Better code splitting strategies"}),"\n",(0,r.jsx)(n.li,{children:"WebAssembly modules for performance-critical paths"}),"\n",(0,r.jsx)(n.li,{children:"More granular event subscriptions"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Building an SDK is a journey, not a destination. Each decision shapes how developers will interact with your platform for years to come."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.p,{children:["_Interested in the technical details? Check out our ",(0,r.jsx)(n.a,{href:"https://github.com/Salad-Labs/loopz-typescript",children:"GitHub repository"})]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},7503:e=>{e.exports=JSON.parse('{"permalink":"/loopz-docs/blog/designing-modular-sdk-architecture-web3","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2024-02-20-designing-modular-sdk-architecture-web3/index.md","source":"@site/blog/2024-02-20-designing-modular-sdk-architecture-web3/index.md","title":"Designing a Modular SDK Architecture for Web3 Applications","description":"Building an SDK is like designing a city - you need to think about how different parts connect, how people (developers) will navigate it, and how it can grow without becoming a maze. When we started building the Loopz SDK, we knew we needed an architecture that could handle authentication, real-time chat, trading, and blockchain interactions - all while remaining intuitive for developers.","date":"2024-02-20T00:00:00.000Z","tags":[{"inline":true,"label":"architecture","permalink":"/loopz-docs/blog/tags/architecture"},{"inline":true,"label":"sdk","permalink":"/loopz-docs/blog/tags/sdk"},{"inline":true,"label":"typescript","permalink":"/loopz-docs/blog/tags/typescript"},{"inline":true,"label":"design-patterns","permalink":"/loopz-docs/blog/tags/design-patterns"},{"inline":true,"label":"web3","permalink":"/loopz-docs/blog/tags/web-3"}],"readingTime":5.31,"hasTruncateMarker":true,"authors":[{"name":"Mattia Migliore","title":"Full Stack Developer, Web3 Dev, Co-founder & CTO Salad Labs","url":"https://www.linkedin.com/in/mattia-migliore-44886090/","page":{"permalink":"/loopz-docs/blog/authors/mattiamigliore"},"socials":{"x":"https://x.com/iamNFTia","linkedin":"https://www.linkedin.com/in/mattia-migliore-44886090/","github":"https://github.com/mattiNFT"},"imageURL":"https://media.licdn.com/dms/image/v2/D4D03AQGgX6OKMrEJig/profile-displayphoto-shrink_400_400/profile-displayphoto-shrink_400_400/0/1689936218116?e=1756339200&v=beta&t=J2TEZjssXl4PIkLrpfZNO48c74lzVb1hdeUCJW9FryA","key":"mattiamigliore"}],"frontMatter":{"slug":"designing-modular-sdk-architecture-web3","title":"Designing a Modular SDK Architecture for Web3 Applications","authors":["mattiamigliore"],"tags":["architecture","sdk","typescript","design-patterns","web3"],"date":"2024-02-20T00:00:00.000Z"},"unlisted":false,"nextItem":{"title":"Designing a React-First Web3 SDK: Patterns and Pitfalls","permalink":"/loopz-docs/blog/designing-react-first-web3-sdk"}}')},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>s});var i=t(6540);const r={},o=i.createContext(r);function a(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);