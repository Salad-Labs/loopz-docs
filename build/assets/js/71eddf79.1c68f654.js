"use strict";(self.webpackChunksdk=self.webpackChunksdk||[]).push([[8862],{522:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>c});var i=t(2013),s=t(4848),a=t(8453);const r={slug:"building-encrypted-chat-web3",title:"Building a Real-Time Encrypted Chat System for Web3 Trading",authors:["mattiamigliore"],tags:["chat","encryption","websocket","architecture","web3"],date:new Date("2024-02-01T00:00:00.000Z")},o="Building a Real-Time Encrypted Chat System for Web3 Trading",l={authorsImageUrls:[void 0]},c=[{value:"The Requirements",id:"the-requirements",level:2},{value:"The Architecture",id:"the-architecture",level:2},{value:"1. The Engine Pattern",id:"1-the-engine-pattern",level:3},{value:"2. End-to-End Encryption",id:"2-end-to-end-encryption",level:3},{value:"3. Real-Time Synchronization",id:"3-real-time-synchronization",level:3},{value:"4. Local-First Architecture",id:"4-local-first-architecture",level:3},{value:"Integration with Trading",id:"integration-with-trading",level:2},{value:"Trade Proposals in Chat",id:"trade-proposals-in-chat",level:3},{value:"Message Types",id:"message-types",level:3},{value:"Performance Optimizations",id:"performance-optimizations",level:2},{value:"1. Message Pagination",id:"1-message-pagination",level:3},{value:"2. Subscription Management",id:"2-subscription-management",level:3},{value:"3. Message Queueing",id:"3-message-queueing",level:3},{value:"Challenges We Faced",id:"challenges-we-faced",level:2},{value:"1. The Typing Indicator Problem",id:"1-the-typing-indicator-problem",level:3},{value:"2. Message Ordering",id:"2-message-ordering",level:3},{value:"3. Group Chat Scaling",id:"3-group-chat-scaling",level:3},{value:"Security Considerations",id:"security-considerations",level:2},{value:"Key Management",id:"key-management",level:3},{value:"Message Integrity",id:"message-integrity",level:3},{value:"Lessons Learned",id:"lessons-learned",level:2},{value:"What&#39;s Next",id:"whats-next",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"When we set out to build Loopz, we knew that trading NFTs and tokens required more than just a marketplace - it needed communication. Traders need to negotiate, discuss, and build relationships. But building a chat system for Web3 comes with unique challenges: How do you ensure privacy? How do you handle decentralized identities? How do you make it performant?"}),"\n",(0,s.jsx)(n.h2,{id:"the-requirements",children:"The Requirements"}),"\n",(0,s.jsx)(n.p,{children:"Our chat system needed to:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Provide end-to-end encryption for all messages"}),"\n",(0,s.jsx)(n.li,{children:"Work with Web3 identities (DIDs)"}),"\n",(0,s.jsx)(n.li,{children:"Support real-time messaging via WebSocket"}),"\n",(0,s.jsx)(n.li,{children:"Handle offline messages and sync"}),"\n",(0,s.jsx)(n.li,{children:"Integrate seamlessly with trading features"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"the-architecture",children:"The Architecture"}),"\n",(0,s.jsx)(n.h3,{id:"1-the-engine-pattern",children:"1. The Engine Pattern"}),"\n",(0,s.jsx)(n.p,{children:'We built our chat system around an "Engine" pattern that manages the complexity:'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"export class Engine {\n  private _client: Client // GraphQL client\n  private _realtimeClient: WebSocket // Real-time subscriptions\n  private _storage: DexieStorage // Local IndexedDB\n  private _connectionParams: {\n    Authorization: string\n    host: string\n  }\n\n  // WebSocket timeout: 5 minutes of inactivity\n  static readonly WS_TIMEOUT = 300000\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"This pattern provides:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Centralized connection management"}),"\n",(0,s.jsx)(n.li,{children:"Automatic reconnection logic"}),"\n",(0,s.jsx)(n.li,{children:"Local storage integration"}),"\n",(0,s.jsx)(n.li,{children:"Clean separation of concerns"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"2-end-to-end-encryption",children:"2. End-to-End Encryption"}),"\n",(0,s.jsx)(n.p,{children:"Every user gets RSA key pairs for message encryption:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'// Key generation during user signup\nconst generateKeys = async () => {\n  const keys = await Crypto.generateKeys("HIGH")\n\n  // Public key: Shared with others\n  // Private key: Encrypted and stored locally\n  return {\n    publicKey: forge.pki.publicKeyToPem(keys.publicKey),\n    privateKey: forge.pki.privateKeyToPem(keys.privateKey),\n  }\n}\n\n// Message encryption flow\nconst sendMessage = async (content: string, conversationId: string) => {\n  // 1. Get conversation\'s AES key\n  const aesKey = getConversationKey(conversationId)\n\n  // 2. Encrypt message content\n  const encrypted = Crypto.encryptAES(content, aesKey.AES, aesKey.iv)\n\n  // 3. Send encrypted message\n  await chat.createMessage({\n    conversationId,\n    content: encrypted,\n    type: "TEXTUAL",\n  })\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"3-real-time-synchronization",children:"3. Real-Time Synchronization"}),"\n",(0,s.jsx)(n.p,{children:"One of our biggest challenges was keeping messages synchronized across devices:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// The sync process\nasync sync(): Promise<void> {\n  // 1. Connect WebSocket\n  await this._handleWSClient()\n\n  // 2. Fetch latest data from server\n  const data = await this._loadDataToLocalDB()\n\n  // 3. Subscribe to real-time updates\n  this._subscribeToUpdates()\n\n  // 4. Handle offline messages\n  await this._processOfflineQueue()\n}\n\n// Real-time subscription example\nonChatMessageEvents(\n  conversationId: string,\n  callback: (message: Message) => void\n) {\n  return this._subscription(\n    'onChatMessageEvents',\n    { conversationId, jwt: Auth.authToken },\n    callback\n  )\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"4-local-first-architecture",children:"4. Local-First Architecture"}),"\n",(0,s.jsx)(n.p,{children:"We use IndexedDB (via Dexie) for local storage, providing:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Offline message access"}),"\n",(0,s.jsx)(n.li,{children:"Fast UI rendering"}),"\n",(0,s.jsx)(n.li,{children:"Reduced server load"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Local database schema\nconst schema = {\n  user: '++[did+organizationId]',\n  conversation: '++[id+userDid], name, type, order',\n  message: '++[id+userDid], conversationId, order, createdAt',\n  member: '++[id+userId], conversationId'\n}\n\n// Syncing local and remote\nprivate async _storeMessageLDB(message: MessageGraphQL) {\n  await this._storage.message.put({\n    id: message.id,\n    content: this._decryptContent(message.content),\n    conversationId: message.conversationId,\n    // ... other fields\n  })\n\n  this._emit('messageCreatedLDB', localMessage)\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"integration-with-trading",children:"Integration with Trading"}),"\n",(0,s.jsx)(n.p,{children:"The real magic happens when chat meets trading:"}),"\n",(0,s.jsx)(n.h3,{id:"trade-proposals-in-chat",children:"Trade Proposals in Chat"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'// Creating a trade proposal message\nconst message = await chat.createMessage({\n  conversationId,\n  type: "TRADE_PROPOSAL",\n  content: "Check out my offer!",\n  proposal: {\n    offered: [{ tokenId: "123", contract: "0x..." }],\n    wanted: [{ amount: "1000000000000000000", token: "ETH" }],\n  },\n})\n'})}),"\n",(0,s.jsx)(n.h3,{id:"message-types",children:"Message Types"}),"\n",(0,s.jsx)(n.p,{children:"We support different message types for different purposes:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'enum MessageType {\n  TEXTUAL = "TEXTUAL", // Regular text\n  ATTACHMENT = "ATTACHMENT", // Files/images\n  TRADE_PROPOSAL = "TRADE_PROPOSAL", // Trade offers\n  NFT = "NFT", // Shared NFTs\n  RENT = "RENT", // Rental proposals\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"performance-optimizations",children:"Performance Optimizations"}),"\n",(0,s.jsx)(n.h3,{id:"1-message-pagination",children:"1. Message Pagination"}),"\n",(0,s.jsx)(n.p,{children:"Loading thousands of messages would kill performance:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"async getMessages(conversationId: string, limit = 20, offset = 0) {\n  // Fetch from local DB first\n  const localMessages = await this._storage.message\n    .where('[conversationId+order]')\n    .between([conversationId, 0], [conversationId, Infinity])\n    .reverse()\n    .limit(limit)\n    .offset(offset)\n    .toArray()\n\n  return localMessages\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-subscription-management",children:"2. Subscription Management"}),"\n",(0,s.jsx)(n.p,{children:"We carefully manage WebSocket subscriptions to prevent memory leaks:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Track all subscriptions\nprivate _subscriptionGarbageCollector: SubscriptionGarbage[] = []\n\n// Cleanup on disconnect\nprivate _reset(): void {\n  this._realtimeClient?.unsubscribeAll()\n  this._offUUIDSubscriptionEvents()\n  this._realtimeClient?.close()\n  this._offEventsFnsCollector = []\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-message-queueing",children:"3. Message Queueing"}),"\n",(0,s.jsx)(n.p,{children:"For reliability, we queue messages when offline:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'// Queue message when offline\nif (!this.isConnected()) {\n  await this._storage.offlineQueue.add({\n    action: "CREATE_MESSAGE",\n    data: messageData,\n    timestamp: Date.now(),\n  })\n  return\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"challenges-we-faced",children:"Challenges We Faced"}),"\n",(0,s.jsx)(n.h3,{id:"1-the-typing-indicator-problem",children:"1. The Typing Indicator Problem"}),"\n",(0,s.jsx)(n.p,{children:'In a decentralized system, implementing "user is typing" is non-trivial:'}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Too many events can overwhelm the WebSocket"}),"\n",(0,s.jsx)(n.li,{children:"Privacy concerns about activity tracking"}),"\n",(0,s.jsx)(n.li,{children:"Battery drain on mobile devices"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Our solution: Local-only typing indicators with smart debouncing."}),"\n",(0,s.jsx)(n.h3,{id:"2-message-ordering",children:"2. Message Ordering"}),"\n",(0,s.jsx)(n.p,{children:"With distributed systems, message ordering becomes complex:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// We use a combination of timestamp and order field\ntype Message = {\n  id: string\n  order: number // Server-assigned order\n  createdAt: Date // Client timestamp\n  serverTimestamp: Date // Server timestamp\n}\n\n// Sort by server order, fallback to timestamp\nmessages.sort((a, b) => a.order - b.order)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-group-chat-scaling",children:"3. Group Chat Scaling"}),"\n",(0,s.jsx)(n.p,{children:"Group chats with hundreds of members require special handling:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Lazy load members\nasync getConversationMembers(conversationId: string) {\n  // Only load members when needed\n  const cached = await this._storage.member\n    .where('conversationId')\n    .equals(conversationId)\n    .toArray()\n\n  if (cached.length > 0) return cached\n\n  // Fetch from server if not cached\n  return this._fetchMembers(conversationId)\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,s.jsx)(n.h3,{id:"key-management",children:"Key Management"}),"\n",(0,s.jsx)(n.p,{children:"The trickiest part of E2E encryption is key management:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Each conversation has its own AES key\ntype ConversationKeys = {\n  AES: string // 256-bit key\n  iv: string // Initialization vector\n}\n\n// Keys are encrypted with each member's public key\ntype ConversationMember = {\n  userId: string\n  encryptedConversationAESKey: string\n  encryptedConversationIVKey: string\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"message-integrity",children:"Message Integrity"}),"\n",(0,s.jsx)(n.p,{children:"We ensure messages can't be tampered with:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Messages are signed before encryption"}),"\n",(0,s.jsx)(n.li,{children:"Server validates message structure"}),"\n",(0,s.jsx)(n.li,{children:"Clients verify decryption success"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"lessons-learned",children:"Lessons Learned"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Start with E2E encryption from day one"})," - Retrofitting encryption is painful"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Local-first is the way"})," - Users expect instant UI updates"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"WebSocket management is critical"})," - Poor connection handling ruins UX"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Plan for scale early"})," - Group chats can grow quickly"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Message types matter"})," - Different content needs different handling"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"whats-next",children:"What's Next"}),"\n",(0,s.jsx)(n.p,{children:"We're constantly improving our chat system:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Voice messages and calls"}),"\n",(0,s.jsx)(n.li,{children:"Improved group chat performance"}),"\n",(0,s.jsx)(n.li,{children:"Cross-device message sync"}),"\n",(0,s.jsx)(n.li,{children:"Richer trade proposal embeds"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Building a chat system for Web3 is challenging, but the result - traders being able to communicate securely while negotiating deals - makes it all worthwhile."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.em,{children:["Want to integrate Loopz chat into your Web3 application? Check out our ",(0,s.jsx)(n.a,{href:"/docs/guides/chat",children:"documentation"})," or ",(0,s.jsx)(n.a,{href:"mailto:dev@saladlabs.com",children:"reach out"})," to our team!"]})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},2013:e=>{e.exports=JSON.parse('{"permalink":"/loopz-docs/blog/building-encrypted-chat-web3","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2024-02-01-building-encrypted-chat-web3.md","source":"@site/blog/2024-02-01-building-encrypted-chat-web3.md","title":"Building a Real-Time Encrypted Chat System for Web3 Trading","description":"When we set out to build Loopz, we knew that trading NFTs and tokens required more than just a marketplace - it needed communication. Traders need to negotiate, discuss, and build relationships. But building a chat system for Web3 comes with unique challenges: How do you ensure privacy? How do you handle decentralized identities? How do you make it performant?","date":"2024-02-01T00:00:00.000Z","tags":[{"inline":true,"label":"chat","permalink":"/loopz-docs/blog/tags/chat"},{"inline":true,"label":"encryption","permalink":"/loopz-docs/blog/tags/encryption"},{"inline":true,"label":"websocket","permalink":"/loopz-docs/blog/tags/websocket"},{"inline":true,"label":"architecture","permalink":"/loopz-docs/blog/tags/architecture"},{"inline":true,"label":"web3","permalink":"/loopz-docs/blog/tags/web-3"}],"readingTime":4.64,"hasTruncateMarker":true,"authors":[{"name":"Mattia Migliore","title":"Full Stack Developer, Web3 Dev, Co-founder & CTO Salad Labs","url":"https://www.linkedin.com/in/mattia-migliore-44886090/","page":{"permalink":"/loopz-docs/blog/authors/mattiamigliore"},"socials":{"x":"https://x.com/iamNFTia","linkedin":"https://www.linkedin.com/in/mattia-migliore-44886090/","github":"https://github.com/mattiNFT"},"imageURL":"https://media.licdn.com/dms/image/v2/D4D03AQGgX6OKMrEJig/profile-displayphoto-shrink_400_400/profile-displayphoto-shrink_400_400/0/1689936218116?e=1756339200&v=beta&t=J2TEZjssXl4PIkLrpfZNO48c74lzVb1hdeUCJW9FryA","key":"mattiamigliore"}],"frontMatter":{"slug":"building-encrypted-chat-web3","title":"Building a Real-Time Encrypted Chat System for Web3 Trading","authors":["mattiamigliore"],"tags":["chat","encryption","websocket","architecture","web3"],"date":"2024-02-01T00:00:00.000Z"},"unlisted":false,"prevItem":{"title":"Designing a React-First Web3 SDK: Patterns and Pitfalls","permalink":"/loopz-docs/blog/designing-react-first-web3-sdk"},"nextItem":{"title":"From Privy to OTP: The Evolution of Authentication in Loopz SDK","permalink":"/loopz-docs/blog/evolution-of-authentication-loopz-sdk"}}')},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var i=t(6540);const s={},a=i.createContext(s);function r(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);