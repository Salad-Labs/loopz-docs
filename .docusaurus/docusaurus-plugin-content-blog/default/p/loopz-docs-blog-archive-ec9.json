{"archive":{"blogPosts":[{"id":"designing-modular-sdk-architecture-web3","metadata":{"permalink":"/loopz-docs/blog/designing-modular-sdk-architecture-web3","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2024-02-20-designing-modular-sdk-architecture-web3/index.md","source":"@site/blog/2024-02-20-designing-modular-sdk-architecture-web3/index.md","title":"Designing a Modular SDK Architecture for Web3 Applications","description":"Building an SDK is like designing a city - you need to think about how different parts connect, how people (developers) will navigate it, and how it can grow without becoming a maze. When we started building the Loopz SDK, we knew we needed an architecture that could handle authentication, real-time chat, trading, and blockchain interactions - all while remaining intuitive for developers.","date":"2024-02-20T00:00:00.000Z","tags":[{"inline":true,"label":"architecture","permalink":"/loopz-docs/blog/tags/architecture"},{"inline":true,"label":"sdk","permalink":"/loopz-docs/blog/tags/sdk"},{"inline":true,"label":"typescript","permalink":"/loopz-docs/blog/tags/typescript"},{"inline":true,"label":"design-patterns","permalink":"/loopz-docs/blog/tags/design-patterns"},{"inline":true,"label":"web3","permalink":"/loopz-docs/blog/tags/web-3"}],"readingTime":5.31,"hasTruncateMarker":true,"authors":[{"name":"Mattia Migliore","title":"Full Stack Developer, Web3 Dev, Co-founder & CTO Salad Labs","url":"https://www.linkedin.com/in/mattia-migliore-44886090/","page":{"permalink":"/loopz-docs/blog/authors/mattiamigliore"},"socials":{"x":"https://x.com/iamNFTia","linkedin":"https://www.linkedin.com/in/mattia-migliore-44886090/","github":"https://github.com/mattiNFT"},"imageURL":"https://media.licdn.com/dms/image/v2/D4D03AQGgX6OKMrEJig/profile-displayphoto-shrink_400_400/profile-displayphoto-shrink_400_400/0/1689936218116?e=1756339200&v=beta&t=J2TEZjssXl4PIkLrpfZNO48c74lzVb1hdeUCJW9FryA","key":"mattiamigliore"}],"frontMatter":{"slug":"designing-modular-sdk-architecture-web3","title":"Designing a Modular SDK Architecture for Web3 Applications","authors":["mattiamigliore"],"tags":["architecture","sdk","typescript","design-patterns","web3"],"date":"2024-02-20T00:00:00.000Z"},"unlisted":false,"nextItem":{"title":"Designing a React-First Web3 SDK: Patterns and Pitfalls","permalink":"/loopz-docs/blog/designing-react-first-web3-sdk"}},"content":"Building an SDK is like designing a city - you need to think about how different parts connect, how people (developers) will navigate it, and how it can grow without becoming a maze. When we started building the Loopz SDK, we knew we needed an architecture that could handle authentication, real-time chat, trading, and blockchain interactions - all while remaining intuitive for developers.\n\n<!--truncate-->\n\n## The Challenge\n\nOur SDK needed to:\n\n- Support multiple independent features (auth, chat, trading, etc.)\n- Work in both React and vanilla JavaScript environments\n- Handle complex state management\n- Provide great TypeScript support\n- Scale without becoming a monolith\n\n## The Architecture\n\n### 1. The Singleton Pattern with a Twist\n\nInstead of traditional singletons, we created a managed singleton system:\n\n```typescript\nexport class Loopz {\n  private static _instance: Loopz\n  private static _config: LoopzConfig\n\n  // Boot method instead of direct instantiation\n  static async boot(\n    config: LoopzConfig,\n    options?: {\n      devMode?: boolean\n      runAdapter?: boolean\n      enableStorage?: boolean\n    }\n  ): Promise<Loopz> {\n    if (!Loopz._instance) {\n      // Create storage connection\n      const storage = await Loopz.createOrConnectToStorage()\n\n      // Initialize instance\n      Loopz._instance = new Loopz(\n        {\n          ...config,\n          storage,\n        },\n        options\n      )\n    }\n\n    return Loopz._instance\n  }\n\n  // Initialize all modules\n  init() {\n    return {\n      auth: Auth.getInstance(),\n      chat: Chat.getInstance(),\n      order: Order.getInstance(),\n      proposal: Proposal.getInstance(),\n      oracle: Oracle.getInstance(),\n      notification: Notification.getInstance(),\n    }\n  }\n}\n```\n\nThis pattern provides:\n\n- Lazy initialization\n- Configuration validation\n- Centralized module management\n- Clean dependency injection\n\n### 2. Module Independence\n\nEach module follows a consistent pattern:\n\n```typescript\nexport class Chat {\n  private static _config: ChatConfig\n  private static _instance: Chat\n\n  // Configuration must happen before instantiation\n  static config(config: ChatConfig) {\n    if (Chat._config) throw new Error(\"Chat already configured\")\n    Chat._config = config\n  }\n\n  static getInstance() {\n    return Chat._instance ?? new Chat()\n  }\n\n  private constructor() {\n    if (!Chat._config) {\n      throw new Error(\"Chat must be configured before getting instance\")\n    }\n    // Initialize with config\n  }\n}\n```\n\nThis ensures:\n\n- Modules can't be used without configuration\n- Each module manages its own lifecycle\n- Clear initialization order\n\n### 3. The Provider Pattern for React\n\nWe created a comprehensive provider system for React applications:\n\n```typescript\n// Root provider that manages everything\nexport const LoopzProvider: FC<LoopzProviderProps> = ({\n  config,\n  chatConfig,\n  devMode = false,\n  children,\n}) => {\n  const [loopz, setLoopz] = useState<ILoopzContext>({\n    initialized: false,\n    instance: null,\n  })\n\n  useEffect(() => {\n    Loopz.boot(config, { devMode }).then((loopz) => {\n      setLoopz({\n        initialized: true,\n        instance: loopz.init(),\n      })\n    })\n  }, [])\n\n  if (!loopz.initialized) return null\n\n  return (\n    <LoopzContext.Provider value={loopz}>\n      <LoopzAuth {...config}>\n        <LoopzAuthProvider>\n          {chatConfig ? (\n            <LoopzChatProvider {...chatConfig}>{children}</LoopzChatProvider>\n          ) : (\n            children\n          )}\n        </LoopzAuthProvider>\n      </LoopzAuth>\n    </LoopzContext.Provider>\n  )\n}\n```\n\n### 4. Hook Architecture\n\nOur hooks follow a consistent pattern with built-in error handling:\n\n```typescript\nexport const useLoopzAuth = () => {\n  const loopzContext = useContext(LoopzContext)\n  const authContext = useContext(LoopzAuthContext)\n\n  if (!loopzContext || !authContext) {\n    throw new Error(\"useLoopzAuth() must be used within <LoopzProvider>\")\n  }\n\n  const { initialized, instance } = loopzContext\n  const { isAuthenticated, isLoading, account } = authContext\n\n  const authenticate = useCallback(() => {\n    if (!initialized) throw new NotInitializedError()\n    if (isLoading) throw new LoadingError(\"authenticate()\", \"Auth\")\n\n    return !isAuthenticated\n      ? instance.auth.authenticate()\n      : Promise.resolve({ auth, account })\n  }, [initialized, isLoading, isAuthenticated])\n\n  return {\n    ...authContext,\n    authenticate,\n    // other methods\n  }\n}\n```\n\n## Type Safety First\n\n### 1. Comprehensive Type Definitions\n\nEvery module has detailed TypeScript definitions:\n\n```typescript\nexport type UseLoopzChat = (config?: {\n  onMessageReceived?: (message: Message) => void\n  onMessageUpdated?: (message: Message) => void\n  onMessageDeleted?: (messageId: string) => void\n  // ... 20+ more event handlers\n}) => LoopzChatContextValue & {\n  connect(): Promise<void>\n  disconnect(): Promise<void>\n  sync(): Promise<void>\n  // ... more methods\n}\n```\n\n### 2. Discriminated Unions for Errors\n\nWe use discriminated unions for better error handling:\n\n```typescript\nexport class QIError extends CombinedError {\n  reason: Maybe<string> = null\n  standardError: boolean = true\n\n  constructor(\n    input: {\n      networkError?: Error\n      graphQLErrors?: ErrorLike[]\n      response?: any\n    },\n    reason: string,\n    standardError: boolean\n  ) {\n    super(input)\n    this.reason = reason\n    this.standardError = standardError\n  }\n}\n```\n\n### 3. Branded Types for Safety\n\nWe use branded types to prevent mixing up IDs:\n\n```typescript\ntype ConversationId = string & { __brand: \"ConversationId\" }\ntype MessageId = string & { __brand: \"MessageId\" }\ntype UserId = string & { __brand: \"UserId\" }\n\n// Prevents accidents like:\n// sendMessage(userId, message) // TypeScript error!\n// sendMessage(conversationId, message) // Correct\n```\n\n## State Management Philosophy\n\n### 1. Local-First with IndexedDB\n\nWe built a complete storage layer on top of Dexie:\n\n```typescript\nexport class DexieStorage {\n  private _db: Dexie\n  private _storageEnabled: boolean = true\n\n  constructor(config: DexieConfig) {\n    this._db = new Dexie(config.dbName)\n\n    // Define schema\n    this._db.version(config.dbVersion).stores({\n      user: \"++[did+organizationId], wallet\",\n      conversation: \"++[id+userDid], name, type, order\",\n      message: \"++[id+userDid], conversationId, order\",\n      member: \"++[id+userId], conversationId\",\n      // ... more tables\n    })\n  }\n\n  // Typed table access\n  get user() {\n    return this._db.table<LocalDBUser>(\"user\")\n  }\n  get conversation() {\n    return this._db.table<LocalDBConversation>(\"conversation\")\n  }\n  // ... more getters\n}\n```\n\n### 2. Event-Driven Architecture\n\nEvery module emits events for state changes:\n\n```typescript\n// Internal event system\nclass EventEmitter {\n  private _events: Map<string, Set<Function>> = new Map()\n\n  on(event: string, callback: Function, once = false) {\n    if (!this._events.has(event)) {\n      this._events.set(event, new Set())\n    }\n\n    const wrapper = once\n      ? (...args: any[]) => {\n          callback(...args)\n          this.off(event, wrapper)\n        }\n      : callback\n\n    this._events.get(event)!.add(wrapper)\n\n    return () => this.off(event, wrapper)\n  }\n\n  emit(event: string, ...args: any[]) {\n    this._events.get(event)?.forEach((callback) => {\n      callback(...args)\n    })\n  }\n}\n```\n\n## Handling Complexity\n\n### 1. The Adapter Pattern\n\nFor third-party integrations, we use adapters:\n\n```typescript\nexport class PrivyAdapter {\n  private _container: HTMLElement\n  private _root: Root\n\n  constructor(options: PrivyAdapterOptions) {\n    // Create isolated React root for Privy\n    this._container = document.createElement(\"div\")\n    document.body.appendChild(this._container)\n    this._root = createRoot(this._container)\n  }\n\n  render() {\n    this._root.render(\n      <PrivyContext appId={this._privyAppId} config={this._privyConfig} />\n    )\n  }\n\n  cleanup() {\n    this._root.unmount()\n    document.body.removeChild(this._container)\n  }\n}\n```\n\n### 2. Graceful Degradation\n\nThe SDK works even when some features aren't available:\n\n```typescript\n// Storage can be disabled for testing\nif (options.enableStorage === false) {\n  storage.disableStorage()\n}\n\n// Chat works without notifications\nif (!instance.notification.isInitialized()) {\n  console.warn(\"Notifications unavailable, chat will work without them\")\n}\n```\n\n## Performance Considerations\n\n### 1. Lazy Loading\n\nModules are only initialized when needed:\n\n```typescript\n// Heavy modules like Order only initialize when used\nasync initializeOrder(wallet: ConnectedWallet) {\n  if (!this._initialized) {\n    await this.init(wallet) // Connect to blockchain\n    this._initialized = true\n  }\n}\n```\n\n### 2. Tree Shaking Support\n\nThe modular architecture enables effective tree shaking:\n\n```typescript\n// Users can import only what they need\nimport { useLoopzAuth } from \"@salad-labs/loopz-typescript/auth\"\n// Instead of importing everything\nimport { useLoopzAuth } from \"@salad-labs/loopz-typescript\"\n```\n\n## Lessons Learned\n\n1. **Configuration Before Instantiation**: Forcing configuration before module creation prevents runtime errors\n\n2. **Consistent Patterns**: Using the same patterns across modules reduces cognitive load\n\n3. **Type Safety Pays Off**: Investing in comprehensive types catches bugs early\n\n4. **Events Over Callbacks**: Event-driven architecture is more flexible than callback props\n\n5. **Provider Composition**: Nested providers allow feature-specific configuration\n\n## What This Enables\n\nOur architecture allows developers to:\n\n```typescript\n// Use only what they need\n<LoopzProvider config={config}>\n  <MyApp /> {/* Just auth */}\n</LoopzProvider>\n\n// Or everything\n<LoopzProvider config={config} chatConfig={chatConfig}>\n  <TradingApp /> {/* Full features */}\n</LoopzProvider>\n\n// Or vanilla JS\nconst loopz = await Loopz.boot(config)\nconst { auth } = loopz.init()\nawait auth.authenticate()\n```\n\n## Future Improvements\n\nWe're constantly evolving the architecture:\n\n- Plugin system for third-party extensions\n- Better code splitting strategies\n- WebAssembly modules for performance-critical paths\n- More granular event subscriptions\n\nBuilding an SDK is a journey, not a destination. Each decision shapes how developers will interact with your platform for years to come.\n\n---\n\n\\_Interested in the technical details? Check out our [GitHub repository](https://github.com/Salad-Labs/loopz-typescript)"},{"id":"designing-react-first-web3-sdk","metadata":{"permalink":"/loopz-docs/blog/designing-react-first-web3-sdk","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2024-03-25-designing-react-first-web3-sdk.md","source":"@site/blog/2024-03-25-designing-react-first-web3-sdk.md","title":"Designing a React-First Web3 SDK: Patterns and Pitfalls","description":"The architectural decisions, patterns, and lessons learned while building a React-first SDK for Web3 trading and chat.","date":"2024-02-15T00:00:00.000Z","tags":[{"inline":true,"label":"react","permalink":"/loopz-docs/blog/tags/react"},{"inline":true,"label":"sdk","permalink":"/loopz-docs/blog/tags/sdk"},{"inline":true,"label":"architecture","permalink":"/loopz-docs/blog/tags/architecture"},{"inline":true,"label":"hooks","permalink":"/loopz-docs/blog/tags/hooks"},{"inline":true,"label":"web3","permalink":"/loopz-docs/blog/tags/web-3"}],"readingTime":4.97,"hasTruncateMarker":true,"authors":[{"name":"Mattia Migliore","title":"Full Stack Developer, Web3 Dev, Co-founder & CTO Salad Labs","url":"https://www.linkedin.com/in/mattia-migliore-44886090/","page":{"permalink":"/loopz-docs/blog/authors/mattiamigliore"},"socials":{"x":"https://x.com/iamNFTia","linkedin":"https://www.linkedin.com/in/mattia-migliore-44886090/","github":"https://github.com/mattiNFT"},"imageURL":"https://media.licdn.com/dms/image/v2/D4D03AQGgX6OKMrEJig/profile-displayphoto-shrink_400_400/profile-displayphoto-shrink_400_400/0/1689936218116?e=1756339200&v=beta&t=J2TEZjssXl4PIkLrpfZNO48c74lzVb1hdeUCJW9FryA","key":"mattiamigliore"}],"frontMatter":{"slug":"designing-react-first-web3-sdk","title":"Designing a React-First Web3 SDK: Patterns and Pitfalls","authors":["mattiamigliore"],"tags":["react","sdk","architecture","hooks","web3"],"date":"2024-02-15T00:00:00.000Z","description":"The architectural decisions, patterns, and lessons learned while building a React-first SDK for Web3 trading and chat."},"unlisted":false,"prevItem":{"title":"Designing a Modular SDK Architecture for Web3 Applications","permalink":"/loopz-docs/blog/designing-modular-sdk-architecture-web3"},"nextItem":{"title":"Building a Real-Time Encrypted Chat System for Web3 Trading","permalink":"/loopz-docs/blog/building-encrypted-chat-web3"}},"content":"Building an SDK is hard. Building a React-first SDK for Web3 is harder. You need to balance developer experience, performance, and the complexities of blockchain interactions. Here's how we approached it with the Loopz SDK.\n\n<!-- truncate -->\n\n## The Vision: Progressive Complexity\n\nWe wanted developers to go from zero to trading platform in minutes, but also have the power to build complex features. This led to our layered architecture:\n\n```typescript\n// Level 1: Dead simple\n;<LoopzProvider config={config}>\n  <App />\n</LoopzProvider>\n\n// Level 2: Hook it up\nconst { authenticate } = useLoopzAuth()\n\n// Level 3: Go deep\nconst chat = Chat.getInstance()\nawait chat.customImplementation()\n```\n\n## Architecture Decisions\n\n### 1. Provider Pattern with Context\n\nWe went all-in on React Context, but with a twist - multiple nested providers for different concerns:\n\n```typescript\nexport const LoopzProvider: FC<LoopzProviderProps> = ({ config, children }) => {\n  // Core SDK initialization\n  const [loopz, setLoopz] = useState<ILoopzContext>({\n    initialized: false,\n    instance: null,\n  })\n\n  useEffect(() => {\n    Loopz.boot(config).then((instance) => {\n      setLoopz({\n        initialized: true,\n        instance: instance.init(),\n      })\n    })\n  }, [])\n\n  if (!loopz.initialized) return null\n\n  return (\n    <LoopzContext.Provider value={loopz}>\n      <LoopzAuth {...config}>\n        <LoopzAuthProvider>\n          <LoopzChatProvider>{children}</LoopzChatProvider>\n        </LoopzAuthProvider>\n      </LoopzAuth>\n    </LoopzContext.Provider>\n  )\n}\n```\n\n**Why nested providers?**\n\n- Separation of concerns\n- Conditional feature loading\n- Independent update cycles\n\n### 2. The Hook Philosophy\n\nEvery major feature gets a hook, but not everything needs to be a hook:\n\n```typescript\n// ✅ Good: Stateful operations\nexport const useLoopzAuth = () => {\n  const { instance } = useLoopz()\n  const [isLoading, setIsLoading] = useState(false)\n\n  const authenticate = useCallback(async () => {\n    setIsLoading(true)\n    try {\n      return await instance.auth.authenticate()\n    } finally {\n      setIsLoading(false)\n    }\n  }, [instance])\n\n  return { authenticate, isLoading }\n}\n\n// ❌ Bad: Simple getters don't need hooks\n// Don't do this:\nexport const useApiKey = () => {\n  const { instance } = useLoopz()\n  return instance.apiKey // No state, no effects, no need for a hook\n}\n```\n\n### 3. Error Boundaries That Make Sense\n\nWe created custom error classes for different scenarios:\n\n```typescript\n// Specific errors for specific problems\nexport class NotInitializedError extends Error {\n  constructor() {\n    super(\"SDK not initialized. Did you wrap your app with LoopzProvider?\")\n    this.name = \"NotInitializedError\"\n  }\n}\n\nexport class ClientCantChatError extends Error {\n  constructor() {\n    super(\"Client cannot chat. E2E keys not generated.\")\n    this.name = \"ClientCantChatError\"\n  }\n}\n\n// Usage in hooks\nconst connect = useCallback(() => {\n  if (!initialized) throw new NotInitializedError()\n  if (!canChat) throw new ClientCantChatError()\n  // ... rest of logic\n}, [initialized, canChat])\n```\n\n### 4. State Management Strategy\n\nWe chose a hybrid approach:\n\n```typescript\n// Global state: In singleton classes\nclass Auth {\n  private static _instance: Auth\n  private static _isAuthenticated: boolean\n\n  static getInstance() {\n    return this._instance || new Auth()\n  }\n}\n\n// Component state: In React Context\nconst ChatContext = createContext<ChatState>({\n  isConnected: false,\n  messages: [],\n  conversations: [],\n})\n\n// Local state: In components\nfunction ChatMessage() {\n  const [isEditing, setIsEditing] = useState(false)\n  // Local UI state stays local\n}\n```\n\n## Patterns We Love\n\n### 1. The Initialization Guard Pattern\n\n```typescript\nexport const useLoopzChat = () => {\n  const { initialized } = useLoopz()\n  const { isAuthenticated } = useLoopzAuth()\n\n  // Guard all methods\n  const connect = useCallback(() => {\n    if (!initialized) throw new NotInitializedError()\n    if (!isAuthenticated) throw new UnauthenticatedError()\n\n    // Safe to proceed\n    return instance.chat.connect()\n  }, [initialized, isAuthenticated])\n}\n```\n\n### 2. Event Emitter + React Bridge\n\n```typescript\n// Core SDK uses event emitters\nclass Chat extends EventEmitter {\n  async sendMessage(content: string) {\n    const message = await this.api.send(content)\n    this.emit(\"messageReceived\", message)\n    return message\n  }\n}\n\n// React hook bridges events to state\nexport const useLoopzChatEvent = (eventName: string, handler: Function) => {\n  const { instance } = useLoopz()\n\n  useEffect(() => {\n    if (!handler) return\n\n    instance.chat.on(eventName, handler)\n    return () => instance.chat.off(eventName, handler)\n  }, [eventName, handler])\n}\n```\n\n### 3. Progressive Enhancement\n\n```typescript\n// Basic usage\nfunction SimpleChat() {\n  const { sendMessage } = useLoopzChat()\n  return <button onClick={() => sendMessage(\"Hello!\")}>Send</button>\n}\n\n// Advanced usage\nfunction AdvancedChat() {\n  const { instance } = useLoopz()\n\n  const sendEncryptedFile = async (file: File) => {\n    // Direct instance access for advanced features\n    const encrypted = await instance.chat.encryptFile(file)\n    return instance.chat.sendAttachment(encrypted)\n  }\n}\n```\n\n## Pitfalls We Hit (So You Don't Have To)\n\n### 1. The SSR Nightmare\n\nNext.js and Web3 don't play nice:\n\n```typescript\n// ❌ This breaks SSR\nexport const LoopzProvider = () => {\n  const storage = new DexieStorage() // IndexedDB doesn't exist in Node!\n}\n\n// ✅ Solution: Dynamic checks\nprivate static async createOrConnectToStorage() {\n  if (typeof window === 'undefined') {\n    return new MemoryStorage() // Fallback for SSR\n  }\n\n  return DexieStorage.createOrConnect({\n    dbName: CLIENT_DB_NAME,\n    dbVersion: 1\n  })\n}\n```\n\n### 2. The Re-render Explosion\n\nEarly versions triggered way too many re-renders:\n\n```typescript\n// ❌ Bad: New object every render\nconst value = {\n  auth: instance.auth,\n  chat: instance.chat,\n  // ... etc\n}\n\n// ✅ Good: Stable references\nconst value = useMemo(\n  () => ({\n    auth: instance.auth,\n    chat: instance.chat,\n  }),\n  [instance]\n)\n```\n\n### 3. The Memory Leak Trap\n\nWebSocket subscriptions are dangerous in React:\n\n```typescript\n// ❌ Leaky implementation\nuseEffect(() => {\n  instance.chat.on(\"message\", handleMessage)\n  // Forgot to cleanup!\n})\n\n// ✅ Proper cleanup\nuseEffect(() => {\n  const key = instance.notification.onMessage(handleMessage)\n\n  return () => {\n    instance.notification.offMessage(key) // Always cleanup!\n  }\n}, [])\n```\n\n## Testing Strategies\n\n### 1. Mock Providers for Testing\n\n```typescript\nexport const MockLoopzProvider: FC = ({ children }) => {\n  const mockInstance = {\n    auth: {\n      authenticate: jest.fn().mockResolvedValue({ user: mockUser }),\n      logout: jest.fn(),\n    },\n    chat: {\n      connect: jest.fn().mockResolvedValue(true),\n      sendMessage: jest.fn(),\n    },\n  }\n\n  return (\n    <LoopzContext.Provider\n      value={{\n        initialized: true,\n        instance: mockInstance,\n      }}\n    >\n      {children}\n    </LoopzContext.Provider>\n  )\n}\n```\n\n### 2. Hook Testing\n\n```typescript\nimport { renderHook } from \"@testing-library/react-hooks\"\n\ntest(\"useLoopzAuth throws when not initialized\", () => {\n  const { result } = renderHook(() => useLoopzAuth(), {\n    wrapper: ({ children }) => (\n      <LoopzContext.Provider value={{ initialized: false }}>\n        {children}\n      </LoopzContext.Provider>\n    ),\n  })\n\n  expect(() => result.current.authenticate()).toThrow(NotInitializedError)\n})\n```\n\n## Performance Optimizations\n\n### 1. Lazy Loading Features\n\n```typescript\n// Only load chat when needed\nconst LoopzChatProvider = lazy(() => import(\"./LoopzChatProvider\"))\n\nfunction App() {\n  const { needsChat } = useFeatureFlags()\n\n  return (\n    <LoopzProvider>\n      {needsChat ? (\n        <Suspense fallback={<ChatLoading />}>\n          <LoopzChatProvider>\n            <Chat />\n          </LoopzChatProvider>\n        </Suspense>\n      ) : (\n        <TradingOnly />\n      )}\n    </LoopzProvider>\n  )\n}\n```\n\n### 2. Subscription Deduplication\n\n```typescript\nclass UUIDSubscriptionClient {\n  private subscriptions = new Map()\n\n  subscribe(query: string, variables: any) {\n    const key = `${query}-${JSON.stringify(variables)}`\n\n    // Return existing subscription\n    if (this.subscriptions.has(key)) {\n      return this.subscriptions.get(key)\n    }\n\n    // Create new subscription with UUID\n    const sub = this.client.request({\n      id: uuid(), // Prevents server duplicates\n      query,\n      variables,\n    })\n\n    this.subscriptions.set(key, sub)\n    return sub\n  }\n}\n```\n\n## Lessons for SDK Developers\n\n1. **Start with the Developer Experience**: Write the code you want developers to write, then make it work.\n\n2. **Embrace TypeScript**: Our types are our documentation. Make them excellent.\n\n3. **Plan for Server-Side Rendering**: Even if you don't need it now, someone will.\n\n4. **Error Messages are UX**: `throw new Error('bad')` helps no one. Be specific.\n\n5. **Test the Unhappy Path**: Network failures, auth errors, race conditions - test them all.\n\n## The Future\n\nWe're exploring:\n\n- **Suspense Integration**: For better loading states\n- **Concurrent Features**: For smoother updates\n- **React Server Components**: For hybrid rendering\n- **Custom DevTools**: For debugging complex states\n\n## Final Thoughts\n\nBuilding a React SDK is about finding the right abstractions. Too low-level and developers struggle. Too high-level and they hit walls. The sweet spot is providing great defaults while keeping escape hatches open.\n\nOur mantra: Make simple things simple, and complex things possible.\n\n---\n\n_Building your own React SDK? We'd love to compare notes. Find us on [GitHub](https://github.com/Salad-Labs/loopz-typescript) or drop us a line at dev@saladlabs.xyz_"},{"id":"building-encrypted-chat-web3","metadata":{"permalink":"/loopz-docs/blog/building-encrypted-chat-web3","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2024-02-01-building-encrypted-chat-web3.md","source":"@site/blog/2024-02-01-building-encrypted-chat-web3.md","title":"Building a Real-Time Encrypted Chat System for Web3 Trading","description":"When we set out to build Loopz, we knew that trading NFTs and tokens required more than just a marketplace - it needed communication. Traders need to negotiate, discuss, and build relationships. But building a chat system for Web3 comes with unique challenges: How do you ensure privacy? How do you handle decentralized identities? How do you make it performant?","date":"2024-02-01T00:00:00.000Z","tags":[{"inline":true,"label":"chat","permalink":"/loopz-docs/blog/tags/chat"},{"inline":true,"label":"encryption","permalink":"/loopz-docs/blog/tags/encryption"},{"inline":true,"label":"websocket","permalink":"/loopz-docs/blog/tags/websocket"},{"inline":true,"label":"architecture","permalink":"/loopz-docs/blog/tags/architecture"},{"inline":true,"label":"web3","permalink":"/loopz-docs/blog/tags/web-3"}],"readingTime":4.64,"hasTruncateMarker":true,"authors":[{"name":"Mattia Migliore","title":"Full Stack Developer, Web3 Dev, Co-founder & CTO Salad Labs","url":"https://www.linkedin.com/in/mattia-migliore-44886090/","page":{"permalink":"/loopz-docs/blog/authors/mattiamigliore"},"socials":{"x":"https://x.com/iamNFTia","linkedin":"https://www.linkedin.com/in/mattia-migliore-44886090/","github":"https://github.com/mattiNFT"},"imageURL":"https://media.licdn.com/dms/image/v2/D4D03AQGgX6OKMrEJig/profile-displayphoto-shrink_400_400/profile-displayphoto-shrink_400_400/0/1689936218116?e=1756339200&v=beta&t=J2TEZjssXl4PIkLrpfZNO48c74lzVb1hdeUCJW9FryA","key":"mattiamigliore"}],"frontMatter":{"slug":"building-encrypted-chat-web3","title":"Building a Real-Time Encrypted Chat System for Web3 Trading","authors":["mattiamigliore"],"tags":["chat","encryption","websocket","architecture","web3"],"date":"2024-02-01T00:00:00.000Z"},"unlisted":false,"prevItem":{"title":"Designing a React-First Web3 SDK: Patterns and Pitfalls","permalink":"/loopz-docs/blog/designing-react-first-web3-sdk"},"nextItem":{"title":"From Privy to OTP: The Evolution of Authentication in Loopz SDK","permalink":"/loopz-docs/blog/evolution-of-authentication-loopz-sdk"}},"content":"When we set out to build Loopz, we knew that trading NFTs and tokens required more than just a marketplace - it needed communication. Traders need to negotiate, discuss, and build relationships. But building a chat system for Web3 comes with unique challenges: How do you ensure privacy? How do you handle decentralized identities? How do you make it performant?\n\n<!--truncate-->\n\n## The Requirements\n\nOur chat system needed to:\n\n- Provide end-to-end encryption for all messages\n- Work with Web3 identities (DIDs)\n- Support real-time messaging via WebSocket\n- Handle offline messages and sync\n- Integrate seamlessly with trading features\n\n## The Architecture\n\n### 1. The Engine Pattern\n\nWe built our chat system around an \"Engine\" pattern that manages the complexity:\n\n```typescript\nexport class Engine {\n  private _client: Client // GraphQL client\n  private _realtimeClient: WebSocket // Real-time subscriptions\n  private _storage: DexieStorage // Local IndexedDB\n  private _connectionParams: {\n    Authorization: string\n    host: string\n  }\n\n  // WebSocket timeout: 5 minutes of inactivity\n  static readonly WS_TIMEOUT = 300000\n}\n```\n\nThis pattern provides:\n\n- Centralized connection management\n- Automatic reconnection logic\n- Local storage integration\n- Clean separation of concerns\n\n### 2. End-to-End Encryption\n\nEvery user gets RSA key pairs for message encryption:\n\n```typescript\n// Key generation during user signup\nconst generateKeys = async () => {\n  const keys = await Crypto.generateKeys(\"HIGH\")\n\n  // Public key: Shared with others\n  // Private key: Encrypted and stored locally\n  return {\n    publicKey: forge.pki.publicKeyToPem(keys.publicKey),\n    privateKey: forge.pki.privateKeyToPem(keys.privateKey),\n  }\n}\n\n// Message encryption flow\nconst sendMessage = async (content: string, conversationId: string) => {\n  // 1. Get conversation's AES key\n  const aesKey = getConversationKey(conversationId)\n\n  // 2. Encrypt message content\n  const encrypted = Crypto.encryptAES(content, aesKey.AES, aesKey.iv)\n\n  // 3. Send encrypted message\n  await chat.createMessage({\n    conversationId,\n    content: encrypted,\n    type: \"TEXTUAL\",\n  })\n}\n```\n\n### 3. Real-Time Synchronization\n\nOne of our biggest challenges was keeping messages synchronized across devices:\n\n```typescript\n// The sync process\nasync sync(): Promise<void> {\n  // 1. Connect WebSocket\n  await this._handleWSClient()\n\n  // 2. Fetch latest data from server\n  const data = await this._loadDataToLocalDB()\n\n  // 3. Subscribe to real-time updates\n  this._subscribeToUpdates()\n\n  // 4. Handle offline messages\n  await this._processOfflineQueue()\n}\n\n// Real-time subscription example\nonChatMessageEvents(\n  conversationId: string,\n  callback: (message: Message) => void\n) {\n  return this._subscription(\n    'onChatMessageEvents',\n    { conversationId, jwt: Auth.authToken },\n    callback\n  )\n}\n```\n\n### 4. Local-First Architecture\n\nWe use IndexedDB (via Dexie) for local storage, providing:\n\n- Offline message access\n- Fast UI rendering\n- Reduced server load\n\n```typescript\n// Local database schema\nconst schema = {\n  user: '++[did+organizationId]',\n  conversation: '++[id+userDid], name, type, order',\n  message: '++[id+userDid], conversationId, order, createdAt',\n  member: '++[id+userId], conversationId'\n}\n\n// Syncing local and remote\nprivate async _storeMessageLDB(message: MessageGraphQL) {\n  await this._storage.message.put({\n    id: message.id,\n    content: this._decryptContent(message.content),\n    conversationId: message.conversationId,\n    // ... other fields\n  })\n\n  this._emit('messageCreatedLDB', localMessage)\n}\n```\n\n## Integration with Trading\n\nThe real magic happens when chat meets trading:\n\n### Trade Proposals in Chat\n\n```typescript\n// Creating a trade proposal message\nconst message = await chat.createMessage({\n  conversationId,\n  type: \"TRADE_PROPOSAL\",\n  content: \"Check out my offer!\",\n  proposal: {\n    offered: [{ tokenId: \"123\", contract: \"0x...\" }],\n    wanted: [{ amount: \"1000000000000000000\", token: \"ETH\" }],\n  },\n})\n```\n\n### Message Types\n\nWe support different message types for different purposes:\n\n```typescript\nenum MessageType {\n  TEXTUAL = \"TEXTUAL\", // Regular text\n  ATTACHMENT = \"ATTACHMENT\", // Files/images\n  TRADE_PROPOSAL = \"TRADE_PROPOSAL\", // Trade offers\n  NFT = \"NFT\", // Shared NFTs\n  RENT = \"RENT\", // Rental proposals\n}\n```\n\n## Performance Optimizations\n\n### 1. Message Pagination\n\nLoading thousands of messages would kill performance:\n\n```typescript\nasync getMessages(conversationId: string, limit = 20, offset = 0) {\n  // Fetch from local DB first\n  const localMessages = await this._storage.message\n    .where('[conversationId+order]')\n    .between([conversationId, 0], [conversationId, Infinity])\n    .reverse()\n    .limit(limit)\n    .offset(offset)\n    .toArray()\n\n  return localMessages\n}\n```\n\n### 2. Subscription Management\n\nWe carefully manage WebSocket subscriptions to prevent memory leaks:\n\n```typescript\n// Track all subscriptions\nprivate _subscriptionGarbageCollector: SubscriptionGarbage[] = []\n\n// Cleanup on disconnect\nprivate _reset(): void {\n  this._realtimeClient?.unsubscribeAll()\n  this._offUUIDSubscriptionEvents()\n  this._realtimeClient?.close()\n  this._offEventsFnsCollector = []\n}\n```\n\n### 3. Message Queueing\n\nFor reliability, we queue messages when offline:\n\n```typescript\n// Queue message when offline\nif (!this.isConnected()) {\n  await this._storage.offlineQueue.add({\n    action: \"CREATE_MESSAGE\",\n    data: messageData,\n    timestamp: Date.now(),\n  })\n  return\n}\n```\n\n## Challenges We Faced\n\n### 1. The Typing Indicator Problem\n\nIn a decentralized system, implementing \"user is typing\" is non-trivial:\n\n- Too many events can overwhelm the WebSocket\n- Privacy concerns about activity tracking\n- Battery drain on mobile devices\n\nOur solution: Local-only typing indicators with smart debouncing.\n\n### 2. Message Ordering\n\nWith distributed systems, message ordering becomes complex:\n\n```typescript\n// We use a combination of timestamp and order field\ntype Message = {\n  id: string\n  order: number // Server-assigned order\n  createdAt: Date // Client timestamp\n  serverTimestamp: Date // Server timestamp\n}\n\n// Sort by server order, fallback to timestamp\nmessages.sort((a, b) => a.order - b.order)\n```\n\n### 3. Group Chat Scaling\n\nGroup chats with hundreds of members require special handling:\n\n```typescript\n// Lazy load members\nasync getConversationMembers(conversationId: string) {\n  // Only load members when needed\n  const cached = await this._storage.member\n    .where('conversationId')\n    .equals(conversationId)\n    .toArray()\n\n  if (cached.length > 0) return cached\n\n  // Fetch from server if not cached\n  return this._fetchMembers(conversationId)\n}\n```\n\n## Security Considerations\n\n### Key Management\n\nThe trickiest part of E2E encryption is key management:\n\n```typescript\n// Each conversation has its own AES key\ntype ConversationKeys = {\n  AES: string // 256-bit key\n  iv: string // Initialization vector\n}\n\n// Keys are encrypted with each member's public key\ntype ConversationMember = {\n  userId: string\n  encryptedConversationAESKey: string\n  encryptedConversationIVKey: string\n}\n```\n\n### Message Integrity\n\nWe ensure messages can't be tampered with:\n\n- Messages are signed before encryption\n- Server validates message structure\n- Clients verify decryption success\n\n## Lessons Learned\n\n1. **Start with E2E encryption from day one** - Retrofitting encryption is painful\n2. **Local-first is the way** - Users expect instant UI updates\n3. **WebSocket management is critical** - Poor connection handling ruins UX\n4. **Plan for scale early** - Group chats can grow quickly\n5. **Message types matter** - Different content needs different handling\n\n## What's Next\n\nWe're constantly improving our chat system:\n\n- Voice messages and calls\n- Improved group chat performance\n- Cross-device message sync\n- Richer trade proposal embeds\n\nBuilding a chat system for Web3 is challenging, but the result - traders being able to communicate securely while negotiating deals - makes it all worthwhile.\n\n---\n\n_Want to integrate Loopz chat into your Web3 application? Check out our [documentation](/docs/guides/chat) or [reach out](mailto:dev@saladlabs.com) to our team!_"},{"id":"evolution-of-authentication-loopz-sdk","metadata":{"permalink":"/loopz-docs/blog/evolution-of-authentication-loopz-sdk","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2024-01-15-evolution-of-authentication-loopz-sdk.md","source":"@site/blog/2024-01-15-evolution-of-authentication-loopz-sdk.md","title":"From Privy to OTP: The Evolution of Authentication in Loopz SDK","description":"When we first started building the Loopz SDK, we made what seemed like an obvious choice: use Privy for all authentication. After all, we were building a Web3 trading platform, and Privy offered seamless wallet connections with social logins. However, as our platform evolved, we discovered that what works for simple DApps doesn't always scale for complex applications with real-time features.","date":"2024-01-15T00:00:00.000Z","tags":[{"inline":true,"label":"authentication","permalink":"/loopz-docs/blog/tags/authentication"},{"inline":true,"label":"architecture","permalink":"/loopz-docs/blog/tags/architecture"},{"inline":true,"label":"web3","permalink":"/loopz-docs/blog/tags/web-3"},{"inline":true,"label":"development","permalink":"/loopz-docs/blog/tags/development"}],"readingTime":3.91,"hasTruncateMarker":true,"authors":[{"name":"Mattia Migliore","title":"Full Stack Developer, Web3 Dev, Co-founder & CTO Salad Labs","url":"https://www.linkedin.com/in/mattia-migliore-44886090/","page":{"permalink":"/loopz-docs/blog/authors/mattiamigliore"},"socials":{"x":"https://x.com/iamNFTia","linkedin":"https://www.linkedin.com/in/mattia-migliore-44886090/","github":"https://github.com/mattiNFT"},"imageURL":"https://media.licdn.com/dms/image/v2/D4D03AQGgX6OKMrEJig/profile-displayphoto-shrink_400_400/profile-displayphoto-shrink_400_400/0/1689936218116?e=1756339200&v=beta&t=J2TEZjssXl4PIkLrpfZNO48c74lzVb1hdeUCJW9FryA","key":"mattiamigliore"}],"frontMatter":{"slug":"evolution-of-authentication-loopz-sdk","title":"From Privy to OTP: The Evolution of Authentication in Loopz SDK","authors":["mattiamigliore"],"tags":["authentication","architecture","web3","development"],"date":"2024-01-15T00:00:00.000Z"},"unlisted":false,"prevItem":{"title":"Building a Real-Time Encrypted Chat System for Web3 Trading","permalink":"/loopz-docs/blog/building-encrypted-chat-web3"}},"content":"When we first started building the Loopz SDK, we made what seemed like an obvious choice: use Privy for all authentication. After all, we were building a Web3 trading platform, and Privy offered seamless wallet connections with social logins. However, as our platform evolved, we discovered that what works for simple DApps doesn't always scale for complex applications with real-time features.\n\n<!--truncate-->\n\n## The Initial Architecture\n\nOur initial authentication flow was straightforward:\n\n```typescript\n// Original implementation (simplified)\nconst { login } = usePrivy()\n\nconst authenticate = async () => {\n  const user = await login()\n  // User authenticated with wallet/social/email via Privy\n  return user\n}\n```\n\nEverything went through Privy - wallet connections, email authentication, social logins. It was elegant and simple.\n\n## The Problem Emerges\n\nAs we developed our real-time chat feature, we hit a major roadblock: **Privy's JWT tokens expire after just 1 hour**.\n\nFor a trading platform where users might browse NFTs for a few minutes, this wasn't an issue. But for a chat application where users stay connected for hours, it became a nightmare:\n\n```typescript\n// The dreaded token expiration during active chat\nWebSocket disconnected: 401 Unauthorized\nToken expired while user was mid-conversation\n```\n\nImagine typing a long message about a trade, hitting send, and getting logged out. Not exactly the user experience we were aiming for.\n\n## The Cost Factor\n\nBeyond the technical limitations, there was another consideration: **cost**. Privy's pricing model made sense for simple authentication needs, but for an application where users might authenticate multiple times per day due to token expiration, the costs started adding up quickly.\n\n## The Hybrid Solution\n\nInstead of completely abandoning Privy, we developed a hybrid approach that leverages the best of both worlds:\n\n### 1. Custom OTP Authentication for App Access\n\nWe built our own email/SMS OTP system for primary authentication:\n\n```typescript\n// New OTP-based authentication\nconst requestOtpCode = async (email: string) => {\n  const response = await fetch(\"/auth/request-code\", {\n    method: \"POST\",\n    body: JSON.stringify({ email }),\n  })\n  // Send 6-digit code via email\n}\n\nconst verifyOtpCode = async (email: string, code: string) => {\n  const response = await fetch(\"/auth/verify-code\", {\n    method: \"POST\",\n    body: JSON.stringify({ email, code }),\n  })\n  // Returns JWT with 18-hour expiration\n  return response.json()\n}\n```\n\n### 2. Privy for Blockchain Operations Only\n\nWe kept Privy, but only for when users need to interact with the blockchain:\n\n```typescript\n// Privy is now only used when creating orders\nconst createOrder = async () => {\n  // Check if wallet is connected\n  const wallet = account.getActiveWallets()[0]\n\n  if (!wallet) {\n    // NOW we trigger Privy\n    // User connects wallet only when needed\n  }\n\n  // Execute blockchain transaction\n  await order.create(wallet, ...)\n}\n```\n\n## The Technical Implementation\n\nThe refactoring wasn't trivial. We had to:\n\n1. **Maintain Backward Compatibility**: Keep the existing API surface while changing the underlying implementation\n2. **Handle Legacy Code**: Deal with remnants of the old system (those `link`/`unlink` methods you might notice)\n3. **Separate Concerns**: Clearly distinguish between app authentication and blockchain authentication\n\nHere's how the new architecture looks:\n\n```typescript\n// App authentication (OTP)\nLoopzAuth Component\n  ├── Handles email/SMS OTP flow\n  ├── Manages JWT tokens (18-hour expiry)\n  └── Controls the authentication UI\n\n// Blockchain authentication (Privy)\nOrder.init(wallet)\n  ├── Triggered only for blockchain operations\n  ├── Uses Privy for wallet connection\n  └── Minimal token expiration impact\n```\n\n## The Results\n\nThe benefits of this hybrid approach have been significant:\n\n1. **Better User Experience**: Users stay logged in for entire trading sessions without interruption\n2. **Reduced Costs**: Dramatic reduction in authentication costs\n3. **Improved Chat Stability**: No more disconnections due to token expiration\n4. **Flexible Authentication**: Users don't need a wallet just to browse and chat\n\n## Lessons Learned\n\nThis evolution taught us several valuable lessons:\n\n1. **One Size Doesn't Fit All**: What works for simple DApps might not work for complex applications\n2. **Cost Matters at Scale**: Always model costs based on realistic usage patterns\n3. **User Experience Trumps Elegance**: A slightly more complex architecture is worth it for a better UX\n4. **Incremental Migration**: You don't have to throw everything away - hybrid solutions can work\n\n## Code Artifacts and Legacy\n\nIf you dig through our codebase, you'll still find remnants of the old system:\n\n```typescript\n// These methods are legacy - no longer functional\nconst link = useCallback((method: AuthLinkMethod) => {\n  // Legacy Privy integration\n}, [])\n\nconst unlink = useCallback((method: AuthLinkMethod) => {\n  // Legacy Privy integration\n}, [])\n```\n\nWe kept these to maintain API compatibility, but they're essentially non-functional now.\n\n## Looking Forward\n\nThis architectural evolution has positioned us well for future growth. We can now:\n\n- Support users who want to chat and browse without wallets\n- Offer extended sessions for better user experience\n- Keep costs predictable as we scale\n- Maintain security where it matters most (blockchain operations)\n\nThe journey from a Privy-only solution to our hybrid approach shows that sometimes the best architecture isn't the simplest one - it's the one that best serves your users' needs.\n\n---\n\n_Have you faced similar authentication challenges in your Web3 projects? We'd love to hear about your experiences and solutions!_"}]}}